{"posts":[{"title":"React + Neo4j 知识图谱可视化展示","text":"","link":"/2024/01/06/React-Neo4j-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA/"},{"title":"2024年目标","text":"2023年年度总结这几天，看到很多人发的朋友圈，在记录这一年来的成就和收获，然后表达对新的一年的美好祝愿。我觉得挺好的。那么回顾我自己的2023呢，好像并没有什么值得回忆的事件，又是随波逐流~~~~ 保上了勉勉强强的研，差强人意好吧，在未来走的道路上面摇摆不定，总是在做错误的选择，然后靠着一些狗屁运气做成一些勉勉强强的事情，但都是些空中楼阁好吧，并没有成系统化，成体系化的技术基础支撑。完成的都是一些demo，而不是项目。 哥们现在只有一年时间积累了，明年的这个时候，应该是在准备暑期实习的事情。 往者不可忆，来者犹可追！ 2024年达成目标吧。 弱者，总是孤独，且自怨自艾的。 随时会删哦！","link":"/2024/01/02/2024%E5%B9%B4%E7%9B%AE%E6%A0%87/"},{"title":"fabric测试工具Caliper的安装配置使用","text":"一、Caliper性能测试工具的配置和使用（1）下载并配置node.js由于服务器上已经配置完成node.js,所以只需要再检查一遍即可。 12node -vnpm -v 返回版本号即配置成功。 （2）创建并初始化Fabric网络由于服务器上已经下载过fabric-sample和fabric2.2.3二进制文件和镜像，所以只需要进行初始化网络即可。 123cd test-network./network.sh up createChannel./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go 通过以上代码完成初始化设置 （3）创建Caliper工作区回到fabric-sample的同一级目录，在同级目录上创建一个名为caliper-workerspace的文件夹，在该文件夹下创建三个名为networks、benchmarks和workload的文件夹。 123456cd ../..mkdir caliper-workspacecd caliper-workspacemkdir networksmkdir benchmarksmkdir workload 然后，在caliper-workspace目录中，安装caliper cli: 1npm install --only=prod @hyperledger/caliper-cli@0.4.0 使用以下终端命令绑定SDK: 1npx caliper bind --caliper-bind-sut fabric:2.1 （4）构建网络配置文件在networks文件夹下创建一个名为networkConfig.json的文件 12cd networkstouch networkConfig.json 将以下内容复制到该文件中并保存： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465{ &quot;version&quot; : &quot;1.0&quot;, &quot;name&quot;: &quot;Caliper test&quot;, &quot;caliper&quot; : { &quot;blockchain&quot;: &quot;fabric&quot; }, &quot;clients&quot;: { &quot;Admin@org1.example.com&quot;: { &quot;client&quot;: { &quot;credentialStore&quot;: { &quot;path&quot;: &quot;/tmp/org1&quot;, &quot;cryptoStore&quot;: { &quot;path&quot;: &quot;/tmp/org1&quot; } }, &quot;organization&quot;: &quot;Org1&quot;, &quot;clientPrivateKey&quot;: { &quot;path&quot;: &quot;../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/priv_sk&quot; }, &quot;clientSignedCert&quot;: { &quot;path&quot;: &quot;../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/Admin@org1.example.com-cert.pem&quot; }, &quot;connection&quot;: { &quot;timeout&quot;: { &quot;peer&quot;: { &quot;endorser&quot;: &quot;300&quot; } } } } } }, &quot;channels&quot;: { &quot;mychannel&quot;: { &quot;created&quot; : true, &quot;contracts&quot;: [ { &quot;id&quot;:&quot;basic&quot;, &quot;version&quot;:&quot;1.0.0&quot; } ] } }, &quot;organizations&quot;:{ &quot;Org1&quot;: { &quot;mspid&quot;: &quot;Org1MSP&quot;, &quot;peers&quot;: [ &quot;peer0.org1.example.com&quot; ] } }, &quot;peers&quot;: { &quot;peer0.org1.example.com&quot;: { &quot;url&quot;: &quot;grpcs://localhost:7051&quot;, &quot;tlsCACerts&quot;: { &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\n&lt;UNIQUE CONTENT&gt;\\n-----END CERTIFICATE-----\\n&quot; }, &quot;grpcOptions&quot;: { &quot;ssl-target-name-override&quot;: &quot;peer0.org1.example.com&quot;, &quot;hostnameOverride&quot;: &quot;peer0.org1.example.com&quot; } } }} 需要将下面的内容进行替换，需要更具自己网络中生成的证书内容进行更改： 查看方式如下： 1cd /home/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com 打开connection-org1.json，复制该文件中”pem”后面的内容，对networkConfig.json文件中的内容进行替换。 （5）构建测试工作负载模块123cd ..cd workloadtouch readAsset.js 将以下内容复制到该文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'use strict';const { WorkloadModuleBase } = require('@hyperledger/caliper-core');class MyWorkload extends WorkloadModuleBase { constructor() { super(); } async initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext) { await super.initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext); for (let i=0; i&lt;this.roundArguments.assets; i++) { const assetID = `${this.workerIndex}_${i}`; console.log(`Worker ${this.workerIndex}: Creating asset ${assetID}`); const request = { contractId: this.roundArguments.contractId, contractFunction: 'CreateAsset', invokerIdentity: 'Admin@org1.example.com', contractArguments: [assetID,'blue','20','penguin','500'], readOnly: false }; await this.sutAdapter.sendRequests(request); } } async submitTransaction() { const randomId = Math.floor(Math.random()*this.roundArguments.assets); const myArgs = { contractId: this.roundArguments.contractId, contractFunction: 'ReadAsset', invokerIdentity: 'Admin@org1.example.com', contractArguments: [`${this.workerIndex}_${randomId}`], readOnly: true }; await this.sutAdapter.sendRequests(myArgs); } async cleanupWorkloadModule() { for (let i=0; i&lt;this.roundArguments.assets; i++) { const assetID = `${this.workerIndex}_${i}`; console.log(`Worker ${this.workerIndex}: Deleting asset ${assetID}`); const request = { contractId: this.roundArguments.contractId, contractFunction: 'DeleteAsset', invokerIdentity: 'Admin@org1.example.com', contractArguments: [assetID], readOnly: false }; await this.sutAdapter.sendRequests(request); } }}function createWorkloadModule() { return new MyWorkload();}module.exports.createWorkloadModule = createWorkloadModule; （6）构建基准测试配置文件在benchmarks文件夹下创建一个名为myAssetBenchmark.yaml的文件 123cd ..cd benchmarkstouch myAssetBenchmark.yaml 将以下内容复制到myAssetBenchmark.yaml的文件中并保存: 1234567891011121314151617181920212223242526test: name: basic-contract-benchmark description: test benchmark workers: type: local number: 2 rounds: - label: readAsset description: Read asset benchmark txDuration: 30 rateControl: type: fixed-load opts: transactionLoad: 2 workload: module: workload/readAsset.js arguments: assets: 10 contractId: basicmonitors: resource: - module: docker options: interval: 5 containers: - all （7）运行Caliper基准测试1npx caliper launch manager --caliper-workspace ./ --caliper-networkconfig networks/networkConfig.json --caliper-benchconfig benchmarks/myAssetBenchmark.yaml --caliper-flow-only-test --caliper-fabric-gateway-enabled --caliper-fabric-gateway-discovery 测试结果如下所示： 吞吐量： 计算机资源占用情况： 同时在caliper-workspace目录下生成了一个名为report.html的报告，使用Xftp工具将该文件从服务器上提取出来。","link":"/2022/03/16/fabric%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Caliper%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"},{"title":"fabric-基于状态的背书(sbe)","text":"1.背书“背书”这个词源来自银行票据业务，传统意义上的背书是指请具有一定公信力的人在票据背面签字以表达对信用的加强和支持，就是让别人提供信誉以及影响力进行支持，让被背书（endorsed）人或者事物提升可信度，更加具有公信力。 在区块链中背书可以理解为承担背书任务的节点为区块链交易进行交易信息验证，对验证通过的交易声明此交易合法的过程和机制。 2.背书节点（endorsement、endorsor）在区块链中承担背书任务的节点即是背书节点。背书节点必须通过有效证书的预期信息的有效签名来证明其合法性。 3.背书策略（endorsement policy）可以理解为是对交易进行背书必须满足的条件，即要得到背书成功的结论，必须满足背书策略中给出的条件。 区块链节点有预先指定的背书策略集，这些背书的条件判断在链码（chaincode）中实现，所有的交易都必须依据背书策略进行交易，因为只有经过背书处理的交易才是合法、被认可的交易。因此背书策略也可以说就是用来指导被选中的节点（背书节点）如何决策交易是否正确的条件。 4.背书验证过程Fabric交易需要首先通过节点的背书，然后再进行交易排序，最后才利用有序交易进行账本的更新。 下面是Fabric背书策略验证过程： 发起交易的时候，发起端应用一般调用SDK指定交易提议发给一个或多个背书节点进行背书验证，接收提议的背书节点在SDK的交易提议请求中指定，如果未指定，则会将交易提议请求发送给加入该通道的所有节点，发送后客户端应用等待背书节点的返回 背书节点收到提议后，首先进行一些检查和签名的验证，包括用客户端（SDK）的公钥验证它的签名、核实客户端是否可以在该channel进行操作、交易是否已被提交、交易提议组织是否正确。验证通过后模拟执行chaincode（不会将结果写入到账本里），生成一个提议结果，并对结果进行背书，即在结果中添加数字签名并利用私钥对结果进行签名 客户端（SDK）收到足够多（背书策略要求）的背书节点的结果后，表示这个交易已经正确背书，然后将交易提议、模拟结果和背书信息打包发给orderer排序节点；如果客户端没有收集到足够多的背书节点反馈的背书信息，这个交易就会被舍弃 orderer节点对来自客户端（SDK）的信息进行排序，并创建区块，然后在通道channel上进行广播； channel上的peer节点接收到交易区块后，验证背书策略是否满足，然后更新账本，至此，背书策略的验证过程完成。 5.基于状态的背书(SBE)基于状态的背书 (SBE) 资产转移示例演示了如何使用关键级别的背书策略来确保资产仅由资产所有者背书。 将使用智能合约完成以下转账场景： （1）将 SBE 智能合约部署到使用 Fabric 测试网络创建的通道。该频道将有两个成员 Org1 和 Org2，他们将参与资产转移。每个组织都运行一个加入通道的对等点。 将SBE部署到Fabric测试网络 12345678910# 部署java链码要提前编译一下# 编译的步骤只需要执行一次，在将网络down之后，不需要重复执行cd /home/fabric-samples/asset-transfer-sbe/chaincode-java./gradlew installDistcd /home/fabric-samples/test-network./network.sh up createChannel# 部署java版本的链码./network.sh deployCC -ccn sbe -ccp ../asset-transfer-sbe/chaincode-java/ -ccl java 创建两个成员Org1和Org2的两个对等点 使用链码背书策略创建资产。 链码级背书策略要求通道上的大多数组织对交易进行背书。这意味着创建资产的交易需要得到属于 Org1 和 Org2 的对等方的背书。创建资产时，智能合约会创建一个基于状态的背书策略，指定只有拥有该资产的组织才能背书更新交易。 由org1创建资产，创建资产的时候需要org1和org2两个组织的背书，创建完成后因为org1是资产所有者，之后就只需要得到org1这个组织的背书就可以。 未来对资产的任何更新，都需要得到 Org1 对等方的背书。 可以通过这个命令查询资产： 1peer chaincode query -C mychannel -n sbe -c '{&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset1&quot;]}' 查询结果如下所示：显示资产1的拥有者是org1,价值是100 （2）仅通过 Org1 背书来更新资产，这将使用链码创建资产时应用于资产的基于状态的背书策略。 通过组织org1进行资产的更新。 查询资产状态，结果如下所示：显示资产1的拥有者是org1,价值是200 而当org2这个组织希望更新资产时，下面有两种情况进行对比： 同时向两个组织发起请求提交，不指定背书组织，即没有setEndorsingOrganizations 这行代码，如下所示： 这项由org2发起的更新请求，它能够获得来自org1的背书，所以更新请求顺利完成。 只向org2这个组织发起更新请求,含有**setEndorsingOrganizations(org2)**这条代码。 运行结果如下所示：（实际情况下一般默认第二种，所以由org2发起的对资产的更新请求会失败） （3）交替验证，将资产转移到 Org2。在转移交易执行期间，链码将创建一个新的基于状态的背书策略，以反映资产的新资产所有者。 源代码如下，首先由org1这个组织发起转移资产的请求，然后获得org1的背书，实现将资产转移到org2的请求。 命令行指令如下： 1peer chaincode invoke -o localhost:7050 --waitForEvent --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n sbe --peerAddresses localhost:7051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt -c '{&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset1&quot;,&quot;Org2User1&quot;,&quot;Org2MSP&quot;]}' 查询资产状态：可以看见资产的拥有者现在变为org2。 （4）再次更新资产，这次以 Org2 作为所有者。因为基于状态的背书策略已经更新，所以这个交易只需要Org2背书即可。 结果如下所示：可以看见资产被成功更新。 而当指定背书组织是org1时，就会报错： 结果如下所示： 总结基于状态的背书(sbe）可以认为任何对资产的操作，只有资产的所有者的背书才能被执行。资产的所有者发生改变时，需要请求获得背书的对象也发生改变。","link":"/2022/03/23/fabric-%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E7%9A%84%E8%83%8C%E4%B9%A6-sbe/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/24/hello-world/"},{"title":"leetcode-二叉树","text":"二叉树1、二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 12输入：root = [1,null,2,3]输出：[1,2,3] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 示例 4： 12输入：root = [1,2]输出：[1,2] 示例 5： 12输入：root = [1,null,2]输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ 1234567891011121314151617// 递归算法class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preOrder(root, result); return result; } public void preOrder(TreeNode root,List&lt;Integer&gt; result) { if (root == null) { return; } result.add(root.val); preOrder(root.left, result); preOrder(root.right, result); }} 1234567891011121314151617181920212223// 迭代算法class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if(node.right != null) { stack.push(node.right); } if(node.left != null) { stack.push(node.left); } } return result; }} 2、二叉树的后序遍历给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[3,2,1] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 提示： 树中节点的数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ 方案一：递归的方法 1.确定递归函数的返回值，参数 2.确定递归函数的终止条件 3.确定单层递归的逻辑 12345678910111213class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); postorderTraver(root,result); return result; } public void postorderTraver(TreeNode root, List&lt;Integer&gt; result) { if(root == null) return; postorderTraver(root.left,result); postorderTraver(root.right,result); result.add(root.val); }} 迭代法： 1234567891011121314151617181920212223242526272829303132class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if(node.left != null) { stack.push(node.left); } if(node.right != null) { stack.push(node.right); } } // int firstIndex = 0; // int secondIndex = result.size() - 1; // 使用 size() 方法获取列表的大小 // while (firstIndex &lt; secondIndex) { // Integer temp = result.get(firstIndex); // 使用 get(index) 方法访问列表中的元素 // result.set(firstIndex, result.get(secondIndex)); // 使用 set(index, value) 方法设置列表中的元素 // result.set(secondIndex, temp); // firstIndex++; // secondIndex--; // } Collections.reverse(result); return result; }} 3、二叉树的中序遍历给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[1,3,2] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 12345678910111213class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorderTraver(root,result); return result; } public void inorderTraver(TreeNode root, List&lt;Integer&gt; result) { if (root == null) return; inorderTraver(root.left,result); result.add(root.val); inorderTraver(root.right,result); }} 迭代法： 12345678910111213141516171819202122232425class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); TreeNode cur = root; while (!stack.isEmpty()) { if (cur.left != null) { stack.push(cur.left); cur = cur.left; } else { TreeNode node = stack.pop(); result.add(node.val); if(node.right != null) { stack.push(node.right); cur = node.right; } } } return result; }} 4、二叉树的统一迭代法12345678910111213141516171819202122232425262728 // 非递归前序遍历，统一迭代法class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return result; stack.push(root); while(!stack.isEmpty()){ TreeNode tmp = stack.peek(); if (tmp != null){ stack.pop(); if(tmp.right != null){ stack.push(tmp.right); } if(tmp.left != null){ stack.push(tmp.left); } stack.push(tmp); stack.push(null); }else { stack.pop(); TreeNode target = stack.pop(); result.add(target.val); } } return result; }} 1234567891011121314151617181920212223242526272829// 非递归中序遍历，统一迭代法class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return result; stack.push(root); while (!stack.isEmpty()) { TreeNode temp = stack.peek(); if(temp != null){ stack.pop(); if(temp.right != null) { stack.push(temp.right); } stack.push(temp); stack.push(null); if(temp.left !=null) { stack.push(temp.left); } }else { stack.pop(); TreeNode target = stack.pop(); result.add(target.val); } } return result; }} 1234567891011121314151617181920212223242526// 非递归后续遍历，统一迭代法 class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return result; stack.push(root); while(!stack.isEmpty()) { TreeNode temp = stack.peek(); if(temp != null) { stack.push(null); if(temp.right != null) { stack.push(temp.right); } if(temp.left != null) { stack.push(temp.left); } } else { stack.pop(); TreeNode target = stack.pop(); result.add(target.val); } } return result; }} 5、二叉树的层序遍历https://leetcode.cn/problems/binary-tree-level-order-traversal/ 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; treeQue = new LinkedList&lt;TreeNode&gt;(); treeQue.offer(root); while (!treeQue.isEmpty()){ int size = treeQue.size(); List &lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); while(size &gt; 0){ TreeNode item = treeQue.poll(); itemList.add(item.val); if(item.left != null){ treeQue.offer(item.left); } if(item.right != null){ treeQue.offer(item.right); } size--; } result.add(itemList); } return result; }} 一口气打10题： 102.二叉树的层序遍历(opens new window) 107.二叉树的层次遍历II(opens new window) 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 12345678910111213141516171819202122232425262728class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if (root == null) { return result; } Queue &lt;TreeNode&gt; treeQue = new LinkedList&lt;TreeNode&gt;(); treeQue.offer(root); while (!treeQue.isEmpty()) { int size = treeQue.size(); List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); while (size &gt; 0) { TreeNode tmp = treeQue.poll(); itemList.add(tmp.val); if (tmp.left != null) { treeQue.offer(tmp.left); } if (tmp.right != null) { treeQue.offer(tmp.right); } size--; } result.add(0,itemList); } return result; }} 在 Java 的 LinkedList 类中，add(int index, E element) 方法用于在指定位置 index 插入元素 element。当我们使用 result.add(0, itemList);，这意味着我们每次都在 result 列表的开头位置插入一个新的列表 itemList。 下面是这个操作背后的一些底层细节：LinkedList 是一个双向链表。每个元素（或称为节点）都包含三个部分：存储的数据、指向前一个元素的链接和指向下一个元素的链接。在开头插入（index = 0）：当在链表的开始处插入一个新元素时，新元素成为新的头节点。新的头节点的“下一个”链接指向原来的头节点，如果原来的链表不是空的，则原来的头节点的“前一个”链接更新为指向新的头节点。此操作的时间复杂度为 O(1)，因为不需要遍历链表即可完成插入。 更新头尾指针：如果链表原来是空的，则新插入的节点既是头节点也是尾节点。如果链表不是空的，只需更新头节点指针（对于在开头插入的情况） 199.二叉树的右视图(opens new window) 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 12输入: [1,2,3,null,5,null,4]输出: [1,3,4] 示例 2: 12输入: [1,null,3]输出: [1,3] 示例 3: 12输入: []输出: [] 提示: 二叉树的节点个数的范围是 [0,100] -100 &lt;= Node.val &lt;= 100 12345678910111213141516171819202122```- [637.二叉树的层平均值(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)- [429.N叉树的层序遍历(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)- [515.在每个树行中找最大值(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)- [116.填充每个节点的下一个右侧节点指针(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)- [117.填充每个节点的下一个右侧节点指针II(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)- [104.二叉树的最大深度(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)- [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)#### 6、翻转二叉树给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。 **示例 1：**![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg) 输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 12345**示例 2：**![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg) 输入：root = [2,1,3]输出：[2,3,1] 123**示例 3：** 输入：root = []输出：[] 123456789101112131415161718192021222324**提示：**- 树中节点数目范围在 `[0, 100]` 内- `-100 &lt;= Node.val &lt;= 100````java//方案一，递归法（前序、后序都可以）class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return root; } swapTree(root); invertTree(root.left); invertTree(root.right); return root; } public void swapTree(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} 12345678910111213141516171819202122232425262728293031323334//迭代法 （深度优先遍历）统一迭代法class Solution { public TreeNode invertTree(TreeNode root) { if (root == null){ return root; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) { TreeNode temp = stack.peek(); if (temp != null) { stack.pop(); if (temp.right != null) { stack.push(temp.right); } stack.push(temp); stack.push(null); if (temp.left != null) { stack.push(temp.left); } } else { stack.pop(); TreeNode target = stack.pop(); swapTree(target); } } return root; } public void swapTree(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} 12345678910111213141516171819202122232425262728//迭代法 （广度优先遍历即层序遍历）class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return root; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); while(!deque.isEmpty()) { for (int size = deque.size(); size &gt; 0; size--) { TreeNode temp = deque.poll(); swapTree(temp); if (temp.left != null) { deque.offer(temp.left); } if (temp.right != null) { deque.offer(temp.right); } } } return root; } public void swapTree(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} 7、对称二叉树给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root = [1,2,2,null,3,null,3]输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 1234567891011121314151617181920212223242526// 递归法class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return compare(root.left,root.right); } public boolean compare(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right != null) { return false; } if (left != null &amp;&amp; right == null) { return false; } if (left == null &amp;&amp; right == null) { return true; } if (left.val != right.val) { return false; } boolean outside = compare(left.left,right.right); boolean inside = compare(left.right,right.left); return outside &amp;&amp; inside; }} 1234567891011121314151617181920212223242526272829303132// 迭代法class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } Deque &lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root.left); deque.offer(root.right); while(!deque.isEmpty()) { TreeNode right = deque.poll(); TreeNode left = deque.poll(); if(right == null &amp;&amp; left != null) { return false; } if(right != null &amp;&amp; left == null) { return false; } if(right == null &amp;&amp; left == null) { continue; } if(right.val != left.val) { return false; } deque.offer(left.left); deque.offer(right.right); deque.offer(left.right); deque.offer(right.left); } return true; }} 两道相似的题： 100.相同的树(opens new window) 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 12输入：p = [1,2,3], q = [1,2,3]输出：true 示例 2： 12输入：p = [1,2], q = [1,null,2]输出：false 示例 3： 12输入：p = [1,2,1], q = [1,1,2]输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -10^4 &lt;= Node.val &lt;= 10^4 1234567891011121314151617181920//递归法class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q != null) { return false; } if (p != null &amp;&amp; q == null) { return false; } if (p == null &amp;&amp; q == null) { return true; } if (p.val != q.val) { return false; } boolean left = isSameTree(p.left,q.left); boolean right = isSameTree(p.right,q.right); return left &amp;&amp; right; }} 1234567891011121314151617181920212223242526272829303132//递归法class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } Deque &lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(p); deque.offer(q); while(!deque.isEmpty()) { TreeNode rightTree = deque.poll(); TreeNode leftTree = deque.poll(); if (rightTree == null &amp;&amp; leftTree !=null) { return false; } if (rightTree != null &amp;&amp; leftTree == null) { return false; } if (rightTree == null &amp;&amp; leftTree == null) { continue; } if (rightTree.val != leftTree.val) { return false; } deque.offer(rightTree.left); deque.offer(leftTree.left); deque.offer(rightTree.right); deque.offer(leftTree.right); } return true; } 572.另一个树的子树 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。 二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。 示例 1： 12输入：root = [3,4,5,1,2], subRoot = [4,1,2]输出：true 示例 2： 12输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]输出：false 提示： root 树上的节点数量范围是 [1, 2000] subRoot 树上的节点数量范围是 [1, 1000] -104 &lt;= root.val &lt;= 104 -104 &lt;= subRoot.val &lt;= 104 12345678910111213141516171819202122232425262728class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { if (root == null) { return false; } if (isSametree(root,subRoot)) { return true; } return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot); } public boolean isSametree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } if (p.val != q.val) { return false; } boolean left = isSametree(p.left,q.left); boolean right = isSametree(p.right,q.right); return left &amp;&amp; right; }} 1//有一种树哈希的算法 1//转化为字符串序列 用kmp算法 8、二叉树的最大深度给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：3 示例 2： 12输入：root = [1,null,2]输出：2 提示： 树中节点的数量在 [0, 104] 区间内。 -100 &lt;= Node.val &lt;= 100 123456789class Solution { public int maxDepth(TreeNode root) { int depth = 0; if (root == null) { return 0; } return Math.max(maxDepth(root.left)+1,maxDepth(root.right)+1); }} 559.n叉树的最大深度(opens new window) 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 示例 1： 12输入：root = [1,null,3,2,4,null,5,6]输出：3 示例 2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：5 提示： 树的深度不会超过 1000 。 树的节点数目位于 [0, 104] 之间。 12345678910111213class Solution { public int maxDepth(Node root) { int depth = 0; if (root == null) { return 0; } for (int i = 0;i&lt;root.children.size();i++) { depth = Math.max(depth,maxDepth(root.children.get(i))); } return depth+1; }} 9、二叉树的最小深度力扣题目链接 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：2 示例 2： 12输入：root = [2,null,3,null,4,null,5,null,6]输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 123456789101112131415161718192021222324252627// 层序遍历class Solution { public int minDepth(TreeNode root) { int depth = 0 ; if (root == null) { return depth; } Deque &lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); while (!deque.isEmpty()) { depth++; for (int i = deque.size(); i &gt; 0 ; i--) { TreeNode tmp = deque.poll(); if (tmp.left != null) { deque.offer(tmp.left); } if (tmp.right != null) { deque.offer(tmp.right); } if(tmp.left == null &amp;&amp; tmp.right == null) { return depth; } } } return depth; }} 1234567891011121314151617181920212223class Solution { public int minDepth(TreeNode root) { int depth = 0 ; if (root == null) { return 0; } int left = minDepth(root.left); int right = minDepth(root.right); if (root.left == null) { depth = right+1; } if (root.right == null) { depth = left+1; } if (root.left == null &amp;&amp; root.right == null) { depth = 1 ; } if (root.left != null &amp;&amp; root.right != null) { depth = Math.min(left,right)+1; } return depth; }} 10、完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 1： 12输入：root = [1,2,3,4,5,6]输出：6 示例 2： 12输入：root = []输出：0 示例 3： 12输入：root = [1]输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？ 123456789101112class Solution { public int countNodes(TreeNode root) { int node = 0; if (root == null) { return 0 ; } int left = countNodes(root.left); int right = countNodes(root.right); node = left + right + 1; return node; }} 1234567891011121314151617181920212223242526class Solution { public int countNodes(TreeNode root) { int result = 0; if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()){ int size = queue.size(); while (size &gt; 0) { TreeNode tmp = queue.poll(); result++; size--; if (tmp.left != null) { queue.offer(tmp.left); } if (tmp.right != null) { queue.offer(tmp.right); } } } return result; }} 1234567891011121314151617181920212223class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } int leftdepth = 0; int rightdepth = 0; TreeNode tmp = root; while (tmp.right != null) { rightdepth++; tmp = tmp.right; } tmp = root; while (tmp.left != null) { leftdepth++; tmp = tmp.left; } if (leftdepth == rightdepth) { return (2&lt;&lt;rightdepth)-1; } return countNodes(root.left)+countNodes(root.right)+1; }} 11、平衡二叉树力扣题目链接 给定一个二叉树，判断它是否是 平衡二叉树 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：true 示例 2： 12输入：root = [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 12输入：root = []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 1234567891011121314151617181920 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } int left = subLength(root.left); int right = subLength(root.right); if (Math.abs(left-right) &gt; 1) { return false; } return isBalanced(root.left) &amp;&amp; isBalanced(root.right); } public int subLength(TreeNode root) { if (root == null) { return 0; } return Math.max(subLength(root.left),subLength(root.right))+1; }} 123456789101112131415161718192021222324class Solution { public boolean isBalanced(TreeNode root) { return getLength(root)==-1 ?false:true; } public int getLength(TreeNode root) { if (root == null) { return 0; } // int result = 0; int leftLength = getLength(root.left); if (leftLength == -1) { return -1; } int rightLength = getLength(root.right); if (rightLength == -1) { return -1; } if (Math.abs(rightLength-leftLength) &gt;1) { return -1; } return Math.max(rightLength,leftLength)+1; }} 12、二叉树的所有路径力扣题目链接 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 12输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 示例 2： 12输入：root = [1]输出：[&quot;1&quot;] 提示： 树中节点的数目在范围 [1, 100] 内 -100 &lt;= Node.val &lt;= 100 1234567891011121314151617181920212223242526272829303132class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (root == null) { return res; } List&lt;Integer&gt; paths = new ArrayList&lt;&gt;(); Backtrace (root,res,paths); return res; } public void Backtrace(TreeNode root,List&lt;String&gt; res,List&lt;Integer&gt; paths) { paths.add(root.val); if (root.left == null &amp;&amp; root.right == null) { StringBuilder sb = new StringBuilder(); for (int i = 0; i&lt;paths.size()-1; i++) { sb.append(paths.get(i)).append(&quot;-&gt;&quot;); } sb.append(paths.get(paths.size()-1)); res.add(sb.toString()); return; } if (root.left != null) { Backtrace(root.left,res,paths); paths.remove(paths.size()-1); } if (root.right != null) { Backtrace(root.right,res,paths); paths.remove(paths.size()-1); } }} 一直往下遍历， 递归的终止条件时遇到左孩子和右孩子都为空，此时将路径转换为字符串并添加到结果列表，然后回溯到上一个节点继续遍历其他子节点。 13、左叶子之和力扣题目链接 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1： 123输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 12输入: root = [1]输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 &lt;= Node.val &lt;= 1000 1234567891011121314151617181920212223// 层序遍历迭代法class Solution { public int sumOfLeftLeaves(TreeNode root) { int sum = 0; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); while (size -- &gt; 0) { TreeNode node = queue.poll(); if (node.left != null) { // 左节点不为空 queue.offer(node.left); if (node.left.left == null &amp;&amp; node.left.right == null){ // 左叶子节点 sum += node.left.val; } } if (node.right != null) queue.offer(node.right); } } return sum; }} 使用层次遍历法，由于不能直接判断本节点是不是左叶子节点，所以需要借助父亲节点进行判断。 12345678910111213class Solution { public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; int leftVal = sumOfLeftLeaves(root.left); int rightVal = sumOfLeftLeaves(root.right); int midVal = 0; if (root.left != null &amp;&amp; root.left.left==null &amp;&amp; root.left.right==null) { midVal += root.left.val; } int result = leftVal + midVal +rightVal; return result; }} 14、找树左下角的值力扣题目链接 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 12输入: root = [2,1,3]输出: 1 示例 2: 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 12345678910111213141516171819202122232425class Solution { public int findBottomLeftValue(TreeNode root) { int result = 0 ; Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) { int length = queue.size(); if (length &gt; 0) { TreeNode tmp = queue.peek(); result = tmp.val; } while (length &gt; 0) { TreeNode tmp = queue.poll(); if (tmp.left != null) { queue.offer(tmp.left); } if (tmp.right != null) { queue.offer(tmp.right); } length--; } } return result; }} 12345678910111213141516171819202122class Solution { private int Deep = -1; private int value = 0; public int findBottomLeftValue(TreeNode root) { value = root.val; findLeftValue(root,0); return value; } public void findLeftValue(TreeNode root,int deep) { if (root ==null) return; if (deep &gt; Deep) { value = root.val; Deep = deep; } if (root.left !=null) { findLeftValue(root.left,deep+1); } if (root.right !=null) { findLeftValue(root.right,deep+1); } }} 通过确定访问的变量是不是处于最大深度的节点来确定。 15、路径总和力扣题目链接 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 12345678910111213141516171819202122class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; targetSum -= root.val; if (root.left == null &amp;&amp; root.right == null) { return targetSum == 0; } if (root.left != null) { boolean leftResult = hasPathSum(root.left,targetSum); if (leftResult) { return true; } } if (root.right != null) { boolean rightResult = hasPathSum(root.right,targetSum); if (rightResult) { return true; } } return false; }} 用目标结果减去节点的值判断是否为0 来确定是否存在具体的路径。 路径综合II https://leetcode.cn/problems/path-sum-ii/ 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 12输入：root = [1,2,3], targetSum = 5输出：[] 示例 3： 12输入：root = [1,2], targetSum = 0输出：[] 提示： 树中节点总数在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); pathFind(root,targetSum,tmp,result); return result; } public void pathFind(TreeNode root, int targetSum,List&lt;Integer&gt; tmp,List&lt;List&lt;Integer&gt;&gt; result) { if (root == null) return; tmp.add(root.val); targetSum -= root.val; if(root.left == null &amp;&amp; root.right == null) { if (targetSum == 0) { // result.add(tmp); result.add(new ArrayList&lt;&gt;(tmp)); } return; } if(root.left != null) { pathFind(root.left,targetSum,tmp,result); tmp.remove(tmp.size()-1); } if(root.right != null) { pathFind(root.right,targetSum,tmp,result); tmp.remove(tmp.size()-1); } }} 关键在于需要创建一个快照，因为直接使用引用的话，后续对tmp的修改会影响result中的数据。 16、从中序与后序遍历序列构建二叉树力扣题目链接 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 示例 2: 12输入：inorder = [-1], postorder = [-1]输出：[-1] 1234567891011121314151617181920212223class Solution { private Map&lt;Integer,Integer&gt;map; public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap&lt;&gt;(); for (int i=0; i&lt;inorder.length; i++) { map.put(inorder[i],i); } TreeNode result = buildTree (inorder,0,inorder.length-1,postorder,0,postorder.length-1); return result; } public TreeNode buildTree(int[] inorder, int inbegin, int inend, int[] postorder, int postbegin, int postend) { if (inbegin &gt; inend || postbegin &gt; postend) { return null; } int rootVal = postorder[postend]; int indexVal = map.get(rootVal); int leftSize = indexVal - inbegin; TreeNode root = new TreeNode(rootVal); root.left = buildTree (inorder,indexVal-leftSize,indexVal-1,postorder,postbegin,postbegin+leftSize-1); root.right = buildTree (inorder,indexVal+1,inend,postorder,postbegin+leftSize,postend-1); return root; }} https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 12输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 示例 2: 12输入: preorder = [-1], inorder = [-1]输出: [-1] 提示: 1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 123456789101112131415161718192021222324class Solution { private Map &lt;Integer,Integer&gt; map; public TreeNode buildTree(int[] preorder, int[] inorder) { map = new HashMap&lt;&gt;(); for (int i=0;i&lt;inorder.length;i++) { map.put(inorder[i],i); } TreeNode result = buildTreeSolution(preorder,0,preorder.length-1,inorder,0,inorder.length-1); return result; } public TreeNode buildTreeSolution (int[] preorder, int preBegin, int preEnd,int[] inorder, int inBegin, int inEnd) { if (preBegin &gt; preEnd || inBegin &gt; inEnd) { return null; } int rootVal = preorder[preBegin]; int indexVal = map.get(rootVal); int leftSize = indexVal - inBegin; TreeNode root = new TreeNode(rootVal); root.left = buildTreeSolution(preorder,preBegin+1,preBegin+leftSize,inorder,inBegin,inBegin+leftSize); root.right = buildTreeSolution(preorder,preBegin+leftSize+1,preEnd,inorder,inBegin+leftSize+1,inEnd); return root; }} 都是以前序或者后序的开头或最后的一个元素 作为中序遍历数组的分界点。 17、最大二叉树给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 *最大二叉树* 。 示例 1： 123456789101112输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示：- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2： 12输入：nums = [3,2,1]输出：[3,null,2,null,1] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 1234567891011121314151617181920212223242526class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { if (nums.length == 0) { return null; } TreeNode result = construct(nums,0,nums.length-1); return result; } public TreeNode construct (int[] nums,int start, int end) { if (start &gt; end) { return null; } int max = nums[start]; int index = start ; for (int i = start; i &lt;= end; i++) { if (nums[i] &gt; max) { max = nums[i]; index = i; } } TreeNode root = new TreeNode(max); root.left = construct(nums,start,index-1); root.right = construct(nums,index+1,end); return root; }} 18、合并二叉树给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例 1： 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 示例 2： 12输入：root1 = [1], root2 = [1,2]输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 1234567891011121314class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null ) { return root2; } if (root2 == null) { return root1; } root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; } 19、二叉搜索树中的搜索给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例 1: 12输入：root = [4,2,7,1,3], val = 2输出：[2,1,3] 示例 2: 12输入：root = [4,2,7,1,3], val = 5输出：[] 提示： 树中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 123456789101112class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null || root.val == val) { return root; } TreeNode left = searchBST(root.left, val); if (left != null) { return left; } return searchBST(root.right, val); }} 20、验证二叉搜索树力扣题目链接 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左 子树 只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 12输入：root = [2,1,3]输出：true 示例 2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 123456789101112131415161718class Solution { private long prev = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } boolean left = isValidBST(root.left); if (!left) { return false; } if (prev &gt;= root.val) { return false; } prev = root.val; boolean right = isValidBST(root.right); return right; }} 123456789101112131415161718192021class Solution { public boolean isValidBST(TreeNode root) { List &lt;Integer&gt; list = new ArrayList&lt;&gt;(); travel(root,list); for(int i = 1; i &lt; list.size(); i++) { if (list.get(i) &lt;= list.get(i-1)) { return false; } } return true; } public void travel(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } travel(root.left,list); list.add(root.val); travel(root.right,list); }} 21、二叉搜索树的最小绝对差力扣题目链接 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例 1： 12输入：root = [4,2,6,1,3]输出：1 示例 2： 12输入：root = [1,0,48,null,null,12,49]输出：1 提示： 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105 12345678910111213141516171819class Solution { private Integer prev = null; private int min = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { travel(root); return min; } public void travel(TreeNode root) { if (root == null) { return; } travel(root.left); if (prev != null) { min = Math.min(min, root.val - prev); } prev = root.val; travel(root.right); }} 22、二叉搜索树中的众数力扣题目链接 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例 1： 12输入：root = [1,null,2,2]输出：[2] 示例 2： 12输入：root = [0]输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 -105 &lt;= Node.val &lt;= 105 123456789101112131415161718192021222324252627282930313233class Solution { private Integer prev = null; private int count = 0; private int maxCount = 0; private List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public int[] findMode(TreeNode root) { travel(root); return result.stream().mapToInt(Integer::intValue).toArray(); } public void travel (TreeNode root) { if (root == null) { return; } travel(root.left); if (prev == null || root.val != prev) { count = 1; } else { count++; } if (count == maxCount) { result.add(root.val); } if (count &gt; maxCount ) { maxCount = count; result.clear(); result.add(root.val); } prev = root.val; travel(root.right); } } 23、二叉搜索树的最近公共祖先24、二叉搜索树中的插入操作25、删除二叉搜索树中的节点26、修剪二叉搜索树27、将有序数组转换为二叉搜索树28、把二叉搜索树转换为累加树","link":"/2024/01/29/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"leetcode 字符串篇","text":"代码随想录 字符串篇一、反转字符串力扣题目链接 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。 示例 1： 12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 提示： 1 &lt;= s.length &lt;= 105 s[i] 都是 ASCII 码表中的可打印字符 1234567891011121314class Solution { public void reverseString(char[] s) { // 注意到虽然是字符串翻转，但传入的值是数组，补充字符串变数组的库函数 toCharArray int left = 0 , right = s.length - 1; while(left &lt; right){ char tmp = s[left]; s[left] = s[right]; s[right] = tmp; left++; right--; } }} 二、反转字符串2力扣题目链接 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot; 示例 2： 12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 10^4 s 仅由小写英文组成 1 &lt;= k &lt;= 10^4 12345678910111213141516171819202122class Solution { public String reverseStr(String s, int k) { char [] ch = s.toCharArray(); for (int i = 0; i &lt; ch.length; i+=2*k){ int start = i; int end = Math.min(ch.length-1 , start+k-1); // 新学到方法，通过异或运算实现两个内容的交换 while(start&lt;end){ ch[start] ^= ch[end]; ch[end] ^= ch[start]; ch[start] ^= ch[end]; start++; end--; } } // 使用String类的valueOf方法 return String.valueOf(ch); // 第二种输出方式，char类型的数组怎么转换成对应的字符串 // return new String(ch); }} 借此契机，学习StringBuffer的知识，下面的解题方法也来自于代码随想录， 12345678910111213141516171819202122232425class Solution { public String reverseStr(String s, int k) { StringBuffer res = new StringBuffer(); int length = s.length(); int start = 0; while (start &lt; length) { // 找到k处和2k处 StringBuffer temp = new StringBuffer(); // 与length进行判断，如果大于length了，那就将其置为length int firstK = (start + k &gt; length) ? length : start + k; int secondK = (start + (2 * k) &gt; length) ? length : start + (2 * k); //无论start所处位置，至少会反转一次 temp.append(s.substring(start, firstK)); res.append(temp.reverse()); // 如果firstK到secondK之间有元素，这些元素直接放入res里即可。 if (firstK &lt; secondK) { //此时剩余长度一定大于k。 res.append(s.substring(firstK, secondK)); } start += (2 * k); } return res.toString(); }} 三、替换数字四、翻转字符串里的单词五、右旋转字符串六、实现strStr()七、重复的子字符串八、总结篇","link":"/2024/01/17/leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/"},{"title":"leetcode 哈希表篇","text":"哈希表的一些概念HashMap 和 HashSet 都是 Java 集合框架的重要组件，它们的主要区别在于以下几个方面： 1.存储方式不同：HashMap 存储的是键值对，将键映射到值，可通过键来访问值；而 HashSet 存储的是唯一值的集合。 2.实现方式不同：HashMap 内部采用的是哈希表数据结构来存储键值对，而 HashSet 采用的是哈希表或者二叉树数据结构来存储唯一值的集合。 3.数据访问方式不同：HashMap 可以通过键来访问对应的值，通过 get() 方法实现；而 HashSet 只能通过迭代器或者 forEach() 方法来遍历元素，没有直接获取单个元素的方法。 4.存储特点不同：HashSet 存储的是唯一的元素集合，不允许存在重复的元素；而 HashMap 存储的是键值对，键是唯一的，而值可以重复。 5.扩容方式不同：HashMap 扩容的时候会重新调整内部存储结构，将所有键值对重新散列到新的存储区域中；而 HashSet 扩容则仅仅只是增加了哈希桶的数量，然后将原有的元素重新分配到新的桶中。 关于HashMap的其他常用方法 put(K key, V value): 将指定的值与此映射中的指定键关联（可选操作）。get(Object key): 返回到指定键所映射的值，或 null（如果此映射包含该键的映射关系）。remove(Object key): 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。containsKey(Object key): 如果此映射包含指定键的映射关系，则返回 true。keySet(): 返回此映射中包含的键的 Set 视图。values(): 返回此映射中包含的值的 Collection 视图。 一、有效的字母异位词力扣题目链接 给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 注意：若 *s* 和 *t* 中每个字符出现的次数都相同，则称 *s* 和 *t* 互为字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 123456789101112131415161718192021class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()){ return false; } Map&lt;Character,Integer&gt; table = new HashMap&lt;Character,Integer&gt;(); for (int i=0 ;i&lt;s.length();i++){ char ch = s.charAt(i); table.put(ch,table.getOrDefault(ch,0)+1); } for (int i=0 ;i&lt;t.length();i++){ char ch = t.charAt(i); table.put(ch,table.getOrDefault(ch,0)-1); if(table.get(ch)&lt;0){ return false; } } return true; }} 二、两个数组的交集力扣题目链接 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Set;class Solution { public int[] intersection(int[] nums1, int[] nums2) { if(nums1 == null || nums1.length==0 || nums2==null || nums2.length==0 ){ return new int[0]; } Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); for (int i : nums1){ set1.add(i); } for(int i : nums2){ if(set1.contains(i)){ set2.add(i); } } int[] result = new int [set2.size()]; int j = 0; for (int i : set2){ result[j++] = i; } return result; }} 注意学习HashSet的用法，在 Java 中，HashSet 是基于 HashMap 实现的，它不允许存储重复的元素。如果尝试向 HashSet 中添加一个已经存在的元素，这个添加操作将会失败，但不会引发任何异常。HashSet 的 add 方法在添加成功时返回 true，如果元素已经存在，则返回 false。 在上述代码中，HashSet 被用于存储 nums1 和 nums2 数组中的元素。由于 HashSet 不存储重复的元素，所以即使 nums1 或 nums2 中包含重复的值，这些值在 HashSet 中只会存储一次。这样，当检查 nums2 中的元素是否存在于 nums1 对应的 HashSet（set1）中时，即使 nums2 中有重复的元素，结果集 resSet 也只会包含不重复的交集元素。 此外，提供另外一种输出方式 1return set2.stream().mapToInt(x -&gt; x).toArray(); 是Java 8中的一行代码，它使用了Java的Stream API和Lambda表达式。这行代码的功能是将一个Integer类型的集合（如Set&lt;Integer&gt;）转换为一个整型数组。下面是这行代码的详细解释： set2.stream()：这会将set2（一个集合）转换为一个流（Stream）。流是Java 8中引入的一个新概念，它允许你以声明性方式处理数据。 .mapToInt(x -&gt; x)：这是一个中间操作，它会将流中的每个元素转换为一个int。x -&gt; x是一个Lambda表达式，表示对流中的每个元素执行的操作。在这里，它实际上是一个恒等函数，因为它返回的值与输入的值相同。 .toArray()：这是一个终端操作，它会收集流中的所有元素，并将它们放入一个数组中。 所以，这行代码的总体效果是将set2中的所有元素收集到一个整型数组中，并返回这个数组。 三、快乐数力扣题目链接 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 1234567输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 示例 2： 12输入：n = 2输出：false 提示： 1 &lt;= n &lt;= 2^31 - 1 123456789101112131415161718192021222324class Solution { public boolean isHappy(int n) { Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); while(n!=1 &amp;&amp; !set1.contains(n)){ set1.add(n); n = getNextNum(n); } if(n==1){ return true; }else{ return false; } } public int getNextNum(int n){ int result=0; while(n!=0){ int num = n%10; result += num * num; n = n/10; } return result; }} 四、两数之和力扣题目链接 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 123456789101112131415161718192021class Solution { public int[] twoSum(int[] nums, int target) { int [] res = new int [2]; if(nums==null || nums.length==0){ return res; } Map&lt;Integer,Integer&gt; result = new HashMap&lt;&gt;(); for (int i = 0 ;i&lt;nums.length;i++){ int tmp = target - nums[i]; if(result.containsKey(tmp)){ res[0] = i; res[1] = result.get(tmp); return res; } else{ result.put(nums[i],i); } } return res; }} 五、四数相加2力扣题目链接 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 1： 123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示： n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 &lt;= n &lt;= 200 -228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228 12345678910111213141516171819202122class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map&lt;Integer,Integer&gt; map1 = new HashMap&lt;&gt;(); int result = 0; for (int i = 0; i &lt; nums1.length ; i++){ for (int j = 0; j &lt; nums2.length ;j++){ int sum = nums1[i] + nums2[j]; map1.put(sum,map1.getOrDefault(sum,0)+1); } } for (int i = 0; i &lt; nums3.length; i++){ for (int j = 0;j &lt; nums4.length; j++){ int sum = 0 - (nums3[i] + nums4[j]); if (map1.containsKey(sum)){ result += map1.get(sum); } } } return result; }} 123456789101112131415161718192021// 代码随想录中较为优雅的写法class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //统计两个数组中的元素之和，同时统计出现的次数，放入map for (int i : nums1) { for (int j : nums2) { int sum = i + j; map.put(sum, map.getOrDefault(sum, 0) + 1); } } //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数 for (int i : nums3) { for (int j : nums4) { res += map.getOrDefault(0 - i - j, 0); } } return res; }} 六、赎金信力扣题目链接 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 1234567891011121314151617181920class Solution { public boolean canConstruct(String ransomNote, String magazine) { Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for (char ch : magazine.toCharArray()){ map.put(ch , map.getOrDefault(ch,0) + 1); } for (char ch : ransomNote.toCharArray()){ if (map.containsKey(ch)){ map.put(ch , map.get(ch)-1); if(map.get(ch) &lt; 0){ return false; } }else{ return false; } } return true; }} 补充一些字符串的用法： 在Java中，遍历字符串通常指的是按顺序访问字符串中的每个字符。由于字符串在Java中被表示为String对象，可以通过几种不同的方式来遍历它们： 使用传统的for循环： 这是最基本的方法，使用字符串的长度和charAt方法来访问每个字符。 12345javaCopy codeString str = &quot;Hello, World!&quot;;for (int i = 0; i &lt; str.length(); i++) { char ch = str.charAt(i); // 处理ch} 使用for-each循环和toCharArray方法： 首先将字符串转换为字符数组，然后使用for-each循环遍历这个数组。 1234javaCopy codeString str = &quot;Hello, World!&quot;;for (char ch : str.toCharArray()) { // 处理ch} 使用Java 8的chars方法： Java 8引入了chars方法，它返回一个IntStream，这是字符的数值表示形式的流。然后可以使用lambda表达式处理每个字符。 12345javaCopy codeString str = &quot;Hello, World!&quot;;str.chars().forEach(c -&gt; { char ch = (char) c; // 处理ch}); 使用Java 8的codePoints方法： 对于需要处理Unicode代理对（即代码点大于U+FFFF的字符）的情况，codePoints方法会更加合适。它返回一个代表字符串中所有代码点的流。 12345javaCopy codeString str = &quot;Hello, World!&quot;;str.codePoints().forEach(cp -&gt; { char[] chars = Character.toChars(cp); // 处理chars}); 在大多数情况下，前两种方法已经足够使用。但是，如果您处理的字符串包含Unicode代理对，或者您想利用流的特性（如并行处理），那么使用chars或codePoints方法可能更合适。 七、三数之和力扣题目链接 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 12345678910111213141516171819202122232425262728293031323334353637// 使用双指针法class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i=0 ;i&lt;nums.length-2;i++){ // 确保在数组中遇到一个与前一个元素相同的元素时，会跳过它，从而避免了重复的三元组。 if (i&gt;0 &amp;&amp; nums[i]==nums[i-1]){ continue; } int left = i+1; int right = nums.length-1; while(left &lt; right){ int sum = nums[i] + nums[left] + nums[right]; if(sum == 0){ result.add(Arrays.asList(nums[i],nums[left],nums[right])); while(left&lt;right&amp;&amp;nums[left]==nums[left+1]){ left++; } while(left&lt;right&amp;&amp;nums[right]==nums[right-1]){ right--; } left++; right--; }else if (sum&lt;0){ left++; }else{ right--; } } } return result; }} 八、四数之和力扣题目链接 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { Long targetNew = (long) target; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums.length&lt;4){ return result; } for(int i = 0; i &lt; nums.length-3; i++){ if (i&gt;0 &amp;&amp;nums[i]==nums[i-1]){ continue; } for(int j = i+1 ;j &lt; nums.length-2; j++){ if((j&gt;i+1)&amp;&amp;(nums[j]==nums[j-1])){ continue; } int left = j+1; int right = nums.length-1; while(left&lt;right){ long sum = (long) nums[i] + nums[j] + nums[left] + nums[right]; if(sum == targetNew){ result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left &lt; right &amp;&amp; nums[left] == nums[left+1]){ left++; } while(left &lt; right &amp;&amp; nums[right] == nums[right-1]){ right--; } left++; right--; }else if(sum &lt; targetNew){ left++; }else{ right--; } } } } return result; }} 其中，有个注意事项是sum超出了 int的最大范围，导致有两个用例没有通过，所以需要进行强制转化。 在Java中，int 类型是一个 32 位的有符号整数类型。其取值范围是从 -2^31 到 2^31 - 1，具体来说： 最小值是 -2,147,483,648 （即 -2^31）。 最大值是 2,147,483,647 （即 2^31 - 1）。 这个范围确保了int类型可以存储的任何整数值都在这个范围内。如果需要更大的数值范围，可以考虑使用long类型，它是一个64位的有符号整数类型，其范围远大于int。 题目中的10^9 其实已经做出了提醒。 九、总结篇","link":"/2024/01/15/leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/"},{"title":"hexo d时出现Error Spawn failed 报错解决","text":"运行hexo d命令时报错12345678FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/usr/local/src/hexo/hanyubolg/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 网上的解决方法：12345678##删除git提交内容文件夹rm -rf .deploy_git/##执行git config --global core.autocrlf false##最后hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 试过很多遍，还是无效。 又看到有人说，是因为网络延迟的问题，当我执行ssh命令时 1$ ssh git@github.com 出现以下信息： 123456789101112131415161718192021@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: POSSIBLE DNS SPOOFING DETECTED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@The RSA host key for github.com has changed,and the key for the corresponding IP address 140.82.113.4is unknown. This could either mean thatDNS SPOOFING is happening or the IP address for the hostand its host key have changed at the same time.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host isSHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s.Please contact your system administrator.Add correct host key in /c/Users/shj/.ssh/known_hosts to get rid of this message.Offending RSA key in /c/Users/shj/.ssh/known_hosts:1RSA host key for github.com has changed and you have requested strict checking.Host key verification failed. 上面这个错误提示意味着连接到的 GitHub 服务器的 RSA 主机密钥（host key）已经改变，可能是由于 DNS 欺骗攻击或 GitHub 服务器的 IP 地址和主机密钥同时更改导致的。 最终的解决方法：我决定重新生成ssh密钥： 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件： 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 找到生成的.ssh文件夹中的id_rsa.pub中的密钥内容，并复制（该文件的地址可以从图中看到） 打开github中SSH and GPG keys页面，将原先的密钥删除，并新建new SSH Key，标题随便填，将复制的内容填入下面的框中，即可生成新的密钥。 然后运行下面两个命令： 12ssh-keygen -R github.comssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts 第一条命令将删除已知主机密钥，第二条命令将从 GitHub 获取新的主机密钥并将其添加到你的已知主机列表中。再次运行以下命令， 1$ ssh git@github.com 运行后出现下面信息： SSH 连接已经成功建立并通过身份验证。然而，由于 GitHub 不提供 shell 访问权限，因此连接被关闭了。这是正常的行为，因为当使用 SSH 连接到 GitHub 时，只能执行特定的 Git 命令，而不能像连接到普通的远程服务器一样执行任意的命令。 之后执行 123hexo cleanhexo ghexo d 就可以正常部署了。","link":"/2023/06/05/hexo%20d%E6%97%B6%E5%87%BA%E7%8E%B0Error%20Spawn%20failed%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"title":"leetcode 栈与队列","text":"栈与队列java中栈与队列的所有常用的实现方法1.用栈实现队列力扣题目链接 2.用队列实现栈力扣题目链接 3.有效的括号力扣题目链接 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]{}&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 '()[]{}' 组成 1234567891011121314151617181920212223242526class Solution { public boolean isValid(String s) { Deque &lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++){ char ch = s.charAt(i); if(ch == '('){ stack.push(')'); }else if (ch == '['){ stack.push(']'); }else if (ch == '{'){ stack.push('}'); }else { if (stack.isEmpty() ||stack.peek()!=ch){ return false; }else{ stack.pop(); } } } if (stack.isEmpty()){ return true; } else { return false; } }} 4.删除字符串中的所有相邻重复项力扣题目链接 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 1234输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。 提示： 1 &lt;= S.length &lt;= 20000 S 仅由小写英文字母组成。 123456789101112131415161718192021class Solution { public String removeDuplicates(String s) { ArrayDeque &lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char ch = s.charAt(i); if (stack.isEmpty() || stack.peek()!=ch) { stack.push(ch); } else { stack.pop(); } } String result = &quot;&quot;; while(!stack.isEmpty()) { result = stack.pop()+result; // result = stack.peek() + result; // stack.pop(); } return result; }} 5.逆波兰表达式求值6.滑动窗口最大值7.前k个高频元素8.总结篇","link":"/2024/01/18/leetcode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"title":"leetcode算法","text":"蹉跎良久，终于开始刷题2023年，研一上修了高级算法与设计，对贪心，分治，动态规划，网络流，np问题，npc问题（规约），近似算法有了一定的了解。 以上只是算法层面，真正实际代码层面，并没有经过一个完整的过程。期间刷过一段时间，但后面又耽搁了。还有一年的时间，将时间段定在寒假结束之前，看这段时间能不能按照代码随想录的顺序完整地刷一遍算法，然后将过程心得记录下来，不管题目是多简单或者多难，将方法，思想，注释完善下。 一、数组引入： 二维数组在内存的空间地址是连续的么？ 不同的编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的，下面是代码随想录提供的测试实验： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void test_arr() { int array[2][3] = { {0, 1, 2}, {3, 4, 5} }; // 打印每个元素的地址 cout &lt;&lt; &amp;array[0][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][2] &lt;&lt; endl; cout &lt;&lt; &amp;array[1][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][2] &lt;&lt; endl;}int main() { test_arr(); return 0;} 运行结果如下： 可以看出地址是16进制，并且相邻两个数组元素相差4个字节（int占用4个字节） 题外话： Q：一个字等于多少个字节？ A：与系统硬件（总线、cpu命令字位数等）有关，不应该毫无前提地说一个字等于多少位。 正确的说法： ①：1字节（byte） = 8位（bit） ②：在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit） ​ 在32位的系统中（比如win32） 1字（word）= 4字节（byte）=32（bit） ​ 在64位的系统中（比如win64）1字（word）= 8字节（byte）=64（bit） JAVA: Java 与 C++ 在内存管理和对程序员的暴露程度上的不同。在 Java 中，指针的概念被隐藏，而且程序员通常无法直接访问或操作对象的内存地址,寻址操作完全交给虚拟机。这是 Java 设计的一部分，旨在提供更安全的编程环境。 123456789101112131415161718public class test1 { public static void main(String[] args) { test_arr(); } public static void test_arr() { int[][] arr = {{1, 2, 3}, {3, 4, 5}, {6, 7, 8}, {9, 9, 9}}; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); // 新的一行 System.out.print(arr[i] + &quot; &quot;); System.out.println(); // 新的一行 } }} 运行结果如下： 当尝试打印一个数组对象（如 arr[0]），Java 默认打印对象的引用地址，通常是一个哈希码或者一种内部表示，而不是内存中的具体地址。这是因为 Java 的安全性和抽象层次，它隐藏了底层的内存管理细节。 如果想查看数组中各个元素的值，需要遍历数组并打印每个元素，而不是直接打印数组对象本身。 二、数组Leetcode题1. 二分查找https://leetcode.cn/problems/search-insert-position/ 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 12345678910111213141516171819202122class Solution { public int search(int[] nums, int target) { if (target &lt; nums[0]||target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left&lt;=right){ int mid = left + ((right-left)&gt;&gt;2); if (nums[mid]&gt;target){ right = mid-1; } else if(nums[mid]&lt;target){ left = mid+1; } else { return mid; } } return -1; }} 有些公司的算法题可能会是acm输入输出模式的，现提供手动输入输出版本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Scanner;public class Solution704 { public int search(int[] nums, int target) { if (target &lt; nums[0]||target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left&lt;=right){ int mid = left + ((right-left)&gt;&gt;2); if (nums[mid]&gt;target){ right = mid-1; } else if(nums[mid]&lt;target){ left = mid+1; } else { return mid; } } return -1; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入数组的长度:&quot;); int n = scanner.nextInt(); int[] nums = new int[n]; System.out.println(&quot;请输入 &quot; + n + &quot; 个升序整数:&quot;); for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); } System.out.println(&quot;请输入目标值:&quot;); int target = scanner.nextInt(); Solution704 solution = new Solution704(); int result = solution.search(nums, target); if (result != -1) { System.out.println(&quot;元素 &quot; + target + &quot; 的索引为: &quot; + result); } else { System.out.println(&quot;元素 &quot; + target + &quot; 不在数组中&quot;); } scanner.close(); }} 如果不想要限制输入数据长度，可以采用可变数组的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;import java.util.Scanner;public class BinarySearchWithArrayList { public static int search(ArrayList&lt;Integer&gt; nums, int target) { int left = 0; int right = nums.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums.get(mid) == target) { return mid; } else if (nums.get(mid) &lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); System.out.println(&quot;请输入升序整数（输入非数字字符结束输入）:&quot;); // 循环读取整数，直到非数字输入 while (scanner.hasNextInt()) { nums.add(scanner.nextInt()); } System.out.println(&quot;请输入目标值:&quot;); scanner.nextLine(); // 清除输入流中的非数字字符 int target = scanner.nextInt(); int result = search(nums, target); if (result != -1) { System.out.println(&quot;元素 &quot; + target + &quot; 的索引为: &quot; + result); } else { System.out.println(&quot;元素 &quot; + target + &quot; 不在数组中&quot;); } scanner.close(); }} 相似题目： 35.搜索插入位置(opens new window) 34.在排序数组中查找元素的第一个和最后一个位置(opens new window) 69.x 的平方根(opens new window) 367.有效的完全平方数 35.搜索插入位置 34.在排序数组中查找元素的第一个和最后一个位置 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 123456789101112```**367.有效的完全平方数**给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。不能使用任何内置的库函数，如 `sqrt` 。**示例 1：** 输入：num = 16输出：true解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 123**示例 2：** 输入：num = 14输出：false解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 1234567891011121314151617181920212223242526272829**提示：**- `1 &lt;= num &lt;= 2^31 - 1````javaclass Solution { public boolean isPerfectSquare(int num) { if(num &lt; 2){ return true; } long left = 2; long right = num/2; while(left&lt;=right){ long mid = left + ((right-left)&gt;&gt;1); long square = mid * mid; if (square &gt; num){ right = mid-1; } else if (square &lt; num){ left = mid+1; } else { return true; } } return false; }} 123456789101112131415161718192021222324252627public class Solution367 { public boolean isPerfectSquare(int num) { if (num &lt; 2) { return true; } long left = 2; long right = num / 2; while (left &lt;= right) { long mid = left + ((right - left) &gt;&gt; 1); long square = mid * mid; if (square &gt; num) { right = mid - 1; } else if (square &lt; num) { left = mid + 1; } else { return true; } } return false; } public static void main(String[] args) { Solution367 solution = new Solution367(); boolean result = solution.isPerfectSquare(808201); System.out.println(result); }} int 类型在 Java 中是一个 32 位的有符号整数类型。其取值范围从 -2,147,483,648（即 -2^31）到 2,147,483,647（即 2^31 - 1）。这意味着 int 类型可以存储的最大正整数是 2,147,483,647。 虽然 int 类型的最大值是 2,147,483,647，这确实足够大，但是代码中，当计算 mid * mid 时，即使 mid 本身是一个有效的 int 值，乘积仍然可能超过 int 类型的最大值。 举个例子，假设 mid 是 50,000，那么 mid * mid 将是 2,500,000,000，这个值已经超出了 int 类型的最大范围（2,147,483,647）。这就是为什么在计算平方时可能发生溢出的原因。 为了避免这个问题，我们需要使用一个更大的数据类型来存储平方的结果。在 Java 中，long 类型是一个 64 位的整数，它的最大值远大于 int，所以使用 long 类型可以防止在计算大数平方时发生溢出。 二、移除元素27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,3,0,4]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 123456789101112class Solution { public int removeElement(int[] nums, int val) { int slowIndex = 0; for (int fastIndex = 0;fastIndex &lt; nums.length;fastIndex++){ if (nums[fastIndex] != val){ nums[slowIndex] = nums[fastIndex]; slowIndex++; } } return slowIndex; }} 在使用双指针方法移除数组中的特定元素后，慢指针（在这个例子中是指针 i）之后的元素实际上是不需要关心的。这是因为函数返回的新长度（i 的值）标志着数组有效部分的结束。在这个新长度之后的元素，即便它们仍然存储在数组中，也被视为“无效”或“不可见”。 重要的是要理解，数组的物理大小（即数组能够容纳的元素数量）并没有改变，因为Java数组的大小在创建后是固定的。这个方法只是改变了数组的“有效”大小。 例如，如果原数组是 [3, 2, 2, 3]，val 是 3，那么在调用 removeElement 方法后，数组可能看起来像 [2, 2, 2, 3]，但方法返回的长度是 2。因此，尽管物理上数组中还有四个元素，只有前两个元素（[2, 2]）是有效的或被认为是数组的新内容。 在实际应用中，通常只关心数组的这个“有效”部分。如果需要在某些情况下消除数组剩余部分的混淆，可以选择将其余部分填充为一个特定的值（如零或某个不可能出现的值），但这通常是不必要的。 相似题目： 26.删除排序数组中的重复项(opens new window) 283.移动零(opens new window) 844.比较含退格的字符串(opens new window) 977.有序数组的平方 26. 删除有序数组中的重复项 给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i];} 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非严格递增 排列 123456789101112class Solution { public int removeDuplicates(int[] nums) { int shortIndex = 0; for (int longIndex = 0;longIndex &lt; nums.length;longIndex++){ if(nums[longIndex]!=nums[shortIndex]){ shortIndex++; nums[shortIndex]=nums[longIndex]; } } return shortIndex+1; }} 通过快慢指针的方法，快指针找到第一个与慢指针指向的不同元素，替换慢指针的下一个元素，最后返回慢指针加1； 283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 12输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 示例 2: 12输入: nums = [0]输出: [0] 提示: 1 &lt;= nums.length &lt;= 104 -231 &lt;= nums[i] &lt;= 231 - 1 123456789101112131415class Solution { public void moveZeroes(int[] nums) { int slowIndex = 0; for (int longIndex = 0 ; longIndex &lt; nums.length; longIndex++){ if(nums[longIndex]!=0){ nums[slowIndex]=nums[longIndex]; slowIndex++; } } while(slowIndex&lt;nums.length){ nums[slowIndex]=0; slowIndex++; } }} 844.比较含退格的字符串(opens new window) 三、有序数组的平方977.有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 123456789101112131415161718class Solution { public int[] sortedSquares(int[] nums) { int fastIndex = nums.length-1; int slowIndex = 0; int [] result = new int [nums.length]; int n = nums.length-1; while (fastIndex &gt;= slowIndex){ if(nums[fastIndex]*nums[fastIndex]&gt;=nums[slowIndex]*nums[slowIndex]){ result[n--]=nums[fastIndex]*nums[fastIndex]; fastIndex--; }else{ result[n--]=nums[slowIndex]*nums[slowIndex]; slowIndex++; } } return result; }} 题意中的非递减顺序排列的数组是解题要点，由于由正负数，所以两端的平方肯定有最大数； 四、长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 10^9 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 12345678910111213141516171819202122方法一：o(n)时间复杂度，滑动窗口（快慢指针方法） class Solution { public int minSubArrayLen(int target, int[] nums) { int result = Integer.MAX_VALUE; int shortIndex = 0; int sum = 0; int tag = 0; for (int longIndex = 0;longIndex &lt; nums.length;longIndex++ ){ sum += nums[longIndex]; while(sum&gt;=target){ sum-=nums[shortIndex]; // tag = longIndex-shortIndex+1; // if (tag&lt;=result){ // result = longIndex-shortIndex+1; // } result = Math.min(result,longIndex-shortIndex+1); shortIndex++; } } return result==Integer.MAX_VALUE ? 0 :result; }} 1方法二：o(nlogn)的fang'f 904.水果成篮 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length 12345678910111213141516171819202122class Solution { public int totalFruit(int[] fruits) { Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;(); int maxFruits = 0, left = 0; for (int right = 0; right &lt; fruits.length; right++) { countMap.put(fruits[right], countMap.getOrDefault(fruits[right], 0) + 1); while (countMap.size() &gt; 2) { countMap.put(fruits[left], countMap.get(fruits[left]) - 1); if (countMap.get(fruits[left]) == 0) { countMap.remove(fruits[left]); } left++; } maxFruits = Math.max(maxFruits, right - left + 1); } return maxFruits; }} 76.最小覆盖子串(opens new window) 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 123输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 'A'、'B' 和 'C'。 示例 2： 123输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。 示例 3: 1234输入: s = &quot;a&quot;, t = &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。 提示： m == s.length n == t.length 1 &lt;= m, n &lt;= 105 s 和 t 由英文字母组成 进阶：你能设计一个在 o(m+n) 时间内解决此问题的算法吗？ 1234567891011121314```#### 五、螺旋矩阵II给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。**示例 1：**![img](https://shjpic.oss-cn-chengdu.aliyuncs.com/spiraln.jpg) 输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 123**示例 2：** 输入：n = 1输出：[[1]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647**提示：**- `1 &lt;= n &lt;= 20`第一种方法：模拟```javaclass Solution { public int[][] generateMatrix(int n) { int[][] matrix = new int[n][n]; int num = 1; int startRow = 0, endRow = n - 1; int startCol = 0, endCol = n - 1; while (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol) { // 从左到右填充顶部行 for (int col = startCol; col &lt;= endCol; col++) { matrix[startRow][col] = num++; } startRow++; // 从上到下填充右侧列 for (int row = startRow; row &lt;= endRow; row++) { matrix[row][endCol] = num++; } endCol--; // 从右到左填充底部行 if (startRow &lt;= endRow) { for (int col = endCol; col &gt;= startCol; col--) { matrix[endRow][col] = num++; } endRow--; } // 从下到上填充左侧列 if (startCol &lt;= endCol) { for (int row = endRow; row &gt;= startRow; row--) { matrix[row][startCol] = num++; } startCol++; } } return matrix; }} 相似题目： 54.螺旋矩阵 剑指Offer 29.顺时针打印矩阵 54.螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int startRow = 0, endRow = matrix.length-1; int startCol = 0, endCol = matrix[0].length-1; while (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol ){ for (int col = startCol; col &lt;= endCol; col++){ result.add(matrix[startRow][col]); } startRow++; for (int row = startRow; row &lt;= endRow; row++){ result.add(matrix[row][endCol]); } endCol--; if(startCol&lt;=endCol &amp;&amp; startRow&lt;=endRow){ for (int col = endCol;col &gt;= startCol;col--){ result.add(matrix[endRow][col]); } endRow--; } if(startRow&lt;=endRow &amp;&amp; startCol&lt;=endCol){ for (int row = endRow;row &gt;=startRow;row--){ result.add(matrix[row][startCol]); } startCol++; } } return result; }} 剑指Offer 29.顺时针打印矩阵 给定一个二维数组 array，请返回「螺旋遍历」该数组的结果。 螺旋遍历：从左上角开始，按照 向右、向下、向左、向上 的顺序 依次 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。 示例 1： 12输入：array = [[1,2,3],[8,9,4],[7,6,5]]输出：[1,2,3,4,5,6,7,8,9] 示例 2： 12输入：array = [[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]输出：[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] 限制： 0 &lt;= array.length &lt;= 100 0 &lt;= array[i].length &lt;= 100 12345678910111213141516171819202122232425262728293031323334class Solution { public int[] spiralArray(int[][] array) { if (array.length==0){ return new int[0]; } int [] result = new int[array.length*array[0].length]; int num = 0; int startRow = 0, endRow = array.length-1; int startCol = 0, endCol = array[0].length-1; while (startRow&lt;=endRow &amp;&amp; startCol&lt;=endCol){ for(int col = startCol ; col&lt;=endCol; col++){ result[num++]=array[startRow][col]; } startRow++; for(int row = startRow; row&lt;=endRow; row++){ result[num++]=array[row][endCol]; } endCol--; if(startCol&lt;=endCol &amp;&amp; startRow&lt;=endRow){ for(int col = endCol;col&gt;=startCol;col--){ result[num++]= array[endRow][col]; } endRow--; } if(startRow&lt;=endRow &amp;&amp; startCol&lt;=endCol){ for(int row = endRow;row&gt;=startRow;row--){ result[num++]= array[row][startCol]; } startCol++; } } return result; }} 六、总结篇","link":"/2024/01/02/leetcode%E7%AE%97%E6%B3%95/"},{"title":"leetcode 双指针法","text":"https://kamacoder.com/problempage.php?pid=1064","link":"/2024/01/18/leetcode-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"},{"title":"leetcode 链表篇","text":"链表的java写法12345678910111213141516171819202122public class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; }} 一、移除链表元素力扣题目链接 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 12345678910方法一：递归法class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null){ return null; } head.next = removeElements(head.next,val); return head.val==val?head.next:head; }} 123456789101112131415161718192021方法二：迭代法class Solution { public ListNode removeElements(ListNode head, int val) { // if (head == null){ // return null; // } // head.next = removeElements(head.next,val); // return head.val==val?head.next:head; ListNode dummyNode = new ListNode(val-1); dummyNode.next = head; ListNode tmp = dummyNode; while (tmp.next != null){ if (tmp.next.val==val){ tmp.next = tmp.next.next; }else{ tmp = tmp.next; } } return dummyNode.next; }} 二、设计链表力扣题目链接 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例： 1234567891011121314输入[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2); // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1); // 返回 2myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-&gt;3myLinkedList.get(1); // 返回 3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class MyLinkedList { ListNode head; int size = 0; private class ListNode { int val; ListNode next; ListNode(int val){ this.val = val; } } public MyLinkedList() { this.head = new ListNode(0); this.size = 0; } public int get(int index) { if(index&lt;0||index&gt;=size){ return -1; }else{ ListNode currentNode = head; for (int i=0;i&lt;=index;i++){ currentNode = currentNode.next; } return currentNode.val; } } public void addAtHead(int val) { addAtIndex(0,val); } public void addAtTail(int val) { addAtIndex(size,val); } public void addAtIndex(int index, int val) { if (index &gt; size) { return; } if (index &lt; 0) { index =0; } size++; ListNode currentNode = head; ListNode pre = head; ListNode addNode = new ListNode(val); for(int i=0 ;i&lt;=index;i++){ pre = currentNode; currentNode = currentNode.next; } pre.next = addNode; addNode.next = currentNode; } public void deleteAtIndex(int index) { if (index&lt;0||index&gt;=size){ return; } size--; ListNode currentNode = head; for(int i=0;i&lt;index;i++){ currentNode = currentNode.next; } if(currentNode.next!=null){ currentNode.next = currentNode.next.next; } }}/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ 三、翻转链表力扣题目链接 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 1234567891011121314151.双指针法：class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cru = head; ListNode tmp = null; while (cru!=null){ tmp = cru.next; cru.next = pre; pre = cru; cru = tmp; } return pre; }} 双指针法的代码很少，但其中的细节特别多，首先是初始化部分，cru为头节点，pre为空 12345678910111213141516171819202122232425262728293031323334353637递归的方法：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseList(ListNode head) { // 1.双指针 // ListNode pre = null; // ListNode cru = head; // ListNode tmp = null; // while (cru!=null){ // tmp = cru.next; // cru.next = pre; // pre = cru; // cru = tmp; // } // return pre; if(head==null){ return null; } if(head.next==null){ return head; } ListNode newHead = reverseList(head.next); head.next.next = head; head.next =null; return newHead; }} 不需要清楚递归的细节是怎么实现的，只需要知道它返回的链表已经是翻转结束的。可以这么理解：1 -&gt; 2 &lt;-3 &lt;- 4 &lt;- 5： 2 3 4 5已经翻转完成，但1的next依然是指向2的，只要让2的next指向1，1再指向null就完成了。 四、两两交换链表中的节点力扣题目链接 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head = []输出：[] 示例 3： 12输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 1234567891011121314151617181920212223242526272829方法一：递归法，时间复杂度是On 空间复杂度也是On/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { if(head==null){ return null; } if(head.next == null){ return head; } ListNode part = swapPairs(head.next.next); ListNode second = head.next; second.next = head; head.next = part; // 返回新的头节点，即原来的第二个节点 return second; }} 12345678910111213141516171819202122232425262728293031方法二：模拟法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode temp ; //用于记录第三个节点后的内容 ListNode dumyhead = new ListNode();//虚拟头节点 dumyhead.next = head; ListNode cul = dumyhead; ListNode firstnode ; ListNode secondnode; while(cul.next!=null&amp;&amp;cul.next.next!=null){ firstnode = cul.next; secondnode = cul.next.next; temp = cul.next.next.next; cul.next = secondnode; secondnode.next = firstnode; firstnode.next = temp; cul = firstnode; } return dumyhead.next; }} 五、删除链表的倒数第N个节点力扣题目链接 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ 12345678910111213141516171819class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fastIndex ; ListNode slowIndex = new ListNode(); fastIndex = head; slowIndex.next = head; ListNode cur = slowIndex; for (int i = 1 ;i &lt;= n ;i++){ fastIndex = fastIndex.next; } while(fastIndex !=null){ fastIndex = fastIndex.next; slowIndex = slowIndex.next; } slowIndex.next = slowIndex.next.next; return cur.next; }} 六、链表相交力扣题目链接 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 有三种方法： 1.hash集合 123456789101112131415161718public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;(); ListNode temp = headA; while (temp!=null){ visited.add(temp); temp = temp.next; } temp = headB; while(temp!=null){ if(visited.contains(temp)){ return temp; } temp=temp.next; } return null; }} 时间复杂度：O(m+n)其中 m 和 n是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。 空间复杂度：O(m)，其中 m 是链表 headA的长度。需要使用哈希集合存储链表 headA中的全部节点。 2.数学方法： 12345678910111213141516171819202122public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA==null || headB==null){ return null; } ListNode tempA = headA; ListNode tempB = headB; while(tempA!=tempB){ if (tempA==null){ tempA = headB; }else { tempA = tempA.next; } if (tempB==null){ tempB = headA; }else { tempB = tempB.next; } } return tempA; }} 时间复杂度：O(m+n)，其中 m和 n 是分别是链表 headA和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。 空间复杂度：O(1)。 3.尾部对齐： 123456789101112131415161718192021222324252627282930313233343536373839public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int lengthA = 0; int lengthB = 0; int gap =0; ListNode tempA = headA; ListNode tempB = headB; while(tempA!=null){ tempA = tempA.next; lengthA++; } while(tempB!=null){ tempB = tempB.next; lengthB++; } if(lengthA&gt;=lengthB){ tempA=headA; tempB=headB; gap = lengthA-lengthB; }else{ tempA=headB; tempB=headA; gap = lengthB-lengthA; } for(int i=1;i&lt;=gap;i++){ tempA=tempA.next; } while(tempA!=null){ if(tempA==tempB){ return tempA; }else{ tempA=tempA.next; tempB=tempB.next; } } return null; }} 七、环形链表2力扣题目链接 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？ 12345678910111213141516方法一：HashSet的方法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode pos = head; Set&lt;ListNode&gt; result = new HashSet&lt;ListNode&gt;(); while(pos!=null){ if(result.contains(pos)){ return pos; }else{ result.add(pos); pos = pos.next; } } return null; }} 时间复杂度：O(N)，其中 N 为链表中节点的数目。恰好需要访问链表中的每一个节点。 空间复杂度：O(N)，其中 N 为链表中节点的数目。需要将链表中的每个节点都保存在哈希表当中。 1234567891011121314151617181920// 方法二：数学推导，快指针每次前进2个节点，慢指针每次前进1个节点，public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null){ fast = fast.next.next; slow = slow.next; if(fast==slow){ fast = head; while(fast!=slow){ fast = fast.next; slow = slow.next; } return fast; } } return null; }} 八、总结篇","link":"/2024/01/11/leetcode-%E9%93%BE%E8%A1%A8%E7%AF%87/"},{"title":"创建github仓库","text":"建立一个GitHub代码仓库并每天提交LeetCode题目的解答是一个很好的练习和记录自己学习进度的方式。以下是具体步骤： 创建GitHub账号：如果你还没有GitHub账号，首先需要在GitHub网站注册一个账号。 创建新的仓库： 登录GitHub账号。 在GitHub页面的右上角，点击 “+” 图标，然后选择 “New repository”。 填写仓库名称（例如：LeetCodeSolutions），可以选择公开或私有仓库。 可以选择初始化仓库，比如添加README文件。 点击 “Create repository”。 在本地电脑设置Git（如果你的电脑上还没有Git）： 下载并安装Git：访问Git官网下载并安装。 配置用户信息：打开Git Bash或命令提示符，输入以下命令： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 将GitHub仓库克隆到本地： 在GitHub仓库页面，找到 “Clone or download”，复制提供的URL。 在本地电脑上选择一个合适的文件夹，右击选择 “Git Bash Here”（或在命令提示符中导航到该文件夹）。 输入以下命令克隆仓库： 1git clone 你复制的URL 添加、提交和推送代码： 在本地仓库文件夹中添加或修改文件（例如，你的LeetCode题解）。 打开Git Bash或命令提示符，切换到仓库文件夹。 使用以下命令将改动添加到本地仓库： 1git add . 提交改动到本地仓库： 1git commit -m &quot;添加了对应的信息，例如完成了某某题目&quot; 将改动推送到GitHub上的仓库： 1git push 每天重复步骤5：每天完成LeetCode题目后，重复步骤5来更新你的GitHub仓库。 通过以上步骤，你就可以建立并维护一个专门用于记录LeetCode题解的GitHub仓库了。这不仅能帮助你跟踪自己的学习进度，还能展示你的编程能力和解题思路。","link":"/2024/01/05/%E5%88%9B%E5%BB%BAgithub%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"碎语","slug":"碎语","link":"/tags/%E7%A2%8E%E8%AF%AD/"},{"name":"实验室区块链","slug":"实验室区块链","link":"/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[{"name":"碎语","slug":"碎语","link":"/categories/%E7%A2%8E%E8%AF%AD/"},{"name":"区块链","slug":"区块链","link":"/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}],"pages":[]}