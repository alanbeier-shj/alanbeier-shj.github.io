{"posts":[{"title":"2024年目标","text":"2023年年度总结 这几天，看到很多人发的朋友圈，在记录这一年来的成就和收获，然后表达对新的一年的美好祝愿。我觉得挺好的。那么回顾我自己的2023呢，好像并没有什么值得回忆的事件，又是随波逐流~~~~ 保上了勉勉强强的研，差强人意好吧，在未来走的道路上面摇摆不定，总是在做错误的选择，然后靠着一些狗屁运气做成一些勉勉强强的事情，但都是些空中楼阁好吧，并没有成系统化，成体系化的技术基础支撑。完成的都是一些demo，而不是项目。 哥们现在只有一年时间积累了，明年的这个时候，应该是在准备暑期实习的事情。 往者不可忆，来者犹可追！ 2024年达成目标吧。 弱者，总是孤独，且自怨自艾的。 随时会删哦！","link":"/2024/01/02/2024%E5%B9%B4%E7%9B%AE%E6%A0%87/"},{"title":"React + Neo4j 知识图谱可视化展示","text":"","link":"/2024/01/06/React-Neo4j-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA/"},{"title":"fabric-基于状态的背书(sbe)","text":"fabric-基于状态的背书(sbe) 1.背书“背书”这个词源来自银行票据业务，传统意义上的背书是指请具有一定公信力的人在票据背面签字以表达对信用的加强和支持，就是让别人提供信誉以及影响力进行支持，让被背书（endorsed）人或者事物提升可信度，更加具有公信力。 在区块链中背书可以理解为承担背书任务的节点为区块链交易进行交易信息验证，对验证通过的交易声明此交易合法的过程和机制。 2.背书节点（endorsement、endorsor）在区块链中承担背书任务的节点即是背书节点。背书节点必须通过有效证书的预期信息的有效签名来证明其合法性。 3.背书策略（endorsement policy）可以理解为是对交易进行背书必须满足的条件，即要得到背书成功的结论，必须满足背书策略中给出的条件。 区块链节点有预先指定的背书策略集，这些背书的条件判断在链码（chaincode）中实现，所有的交易都必须依据背书策略进行交易，因为只有经过背书处理的交易才是合法、被认可的交易。因此背书策略也可以说就是用来指导被选中的节点（背书节点）如何决策交易是否正确的条件。 4.背书验证过程Fabric交易需要首先通过节点的背书，然后再进行交易排序，最后才利用有序交易进行账本的更新。 下面是Fabric背书策略验证过程： 发起交易的时候，发起端应用一般调用SDK指定交易提议发给一个或多个背书节点进行背书验证，接收提议的背书节点在SDK的交易提议请求中指定，如果未指定，则会将交易提议请求发送给加入该通道的所有节点，发送后客户端应用等待背书节点的返回 背书节点收到提议后，首先进行一些检查和签名的验证，包括用客户端（SDK）的公钥验证它的签名、核实客户端是否可以在该channel进行操作、交易是否已被提交、交易提议组织是否正确。验证通过后模拟执行chaincode（不会将结果写入到账本里），生成一个提议结果，并对结果进行背书，即在结果中添加数字签名并利用私钥对结果进行签名 客户端（SDK）收到足够多（背书策略要求）的背书节点的结果后，表示这个交易已经正确背书，然后将交易提议、模拟结果和背书信息打包发给orderer排序节点；如果客户端没有收集到足够多的背书节点反馈的背书信息，这个交易就会被舍弃 orderer节点对来自客户端（SDK）的信息进行排序，并创建区块，然后在通道channel上进行广播； channel上的peer节点接收到交易区块后，验证背书策略是否满足，然后更新账本，至此，背书策略的验证过程完成。 5.基于状态的背书(SBE)基于状态的背书 (SBE) 资产转移示例演示了如何使用关键级别的背书策略来确保资产仅由资产所有者背书。 将使用智能合约完成以下转账场景： （1）将 SBE 智能合约部署到使用 Fabric 测试网络创建的通道。该频道将有两个成员 Org1 和 Org2，他们将参与资产转移。每个组织都运行一个加入通道的对等点。 将SBE部署到Fabric测试网络 12345678910# 部署java链码要提前编译一下# 编译的步骤只需要执行一次，在将网络down之后，不需要重复执行cd /home/fabric-samples/asset-transfer-sbe/chaincode-java./gradlew installDistcd /home/fabric-samples/test-network./network.sh up createChannel# 部署java版本的链码./network.sh deployCC -ccn sbe -ccp ../asset-transfer-sbe/chaincode-java/ -ccl java 创建两个成员Org1和Org2的两个对等点 使用链码背书策略创建资产。 链码级背书策略要求通道上的大多数组织对交易进行背书。这意味着创建资产的交易需要得到属于 Org1 和 Org2 的对等方的背书。创建资产时，智能合约会创建一个基于状态的背书策略，指定只有拥有该资产的组织才能背书更新交易。 由org1创建资产，创建资产的时候需要org1和org2两个组织的背书，创建完成后因为org1是资产所有者，之后就只需要得到org1这个组织的背书就可以。 未来对资产的任何更新，都需要得到 Org1 对等方的背书。 可以通过这个命令查询资产： 1peer chaincode query -C mychannel -n sbe -c '{&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset1&quot;]}' 查询结果如下所示：显示资产1的拥有者是org1,价值是100 （2）仅通过 Org1 背书来更新资产，这将使用链码创建资产时应用于资产的基于状态的背书策略。 通过组织org1进行资产的更新。 查询资产状态，结果如下所示：显示资产1的拥有者是org1,价值是200 而当org2这个组织希望更新资产时，下面有两种情况进行对比： 同时向两个组织发起请求提交，不指定背书组织，即没有setEndorsingOrganizations 这行代码，如下所示： 这项由org2发起的更新请求，它能够获得来自org1的背书，所以更新请求顺利完成。 只向org2这个组织发起更新请求,含有**setEndorsingOrganizations(org2)**这条代码。 运行结果如下所示：（实际情况下一般默认第二种，所以由org2发起的对资产的更新请求会失败） （3）交替验证，将资产转移到 Org2。在转移交易执行期间，链码将创建一个新的基于状态的背书策略，以反映资产的新资产所有者。 源代码如下，首先由org1这个组织发起转移资产的请求，然后获得org1的背书，实现将资产转移到org2的请求。 命令行指令如下： 1peer chaincode invoke -o localhost:7050 --waitForEvent --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n sbe --peerAddresses localhost:7051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt -c '{&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset1&quot;,&quot;Org2User1&quot;,&quot;Org2MSP&quot;]}' 查询资产状态：可以看见资产的拥有者现在变为org2。 （4）再次更新资产，这次以 Org2 作为所有者。因为基于状态的背书策略已经更新，所以这个交易只需要Org2背书即可。 结果如下所示：可以看见资产被成功更新。 而当指定背书组织是org1时，就会报错： 结果如下所示： 总结基于状态的背书(sbe）可以认为任何对资产的操作，只有资产的所有者的背书才能被执行。资产的所有者发生改变时，需要请求获得背书的对象也发生改变。","link":"/2022/03/23/fabric-%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E7%9A%84%E8%83%8C%E4%B9%A6-sbe/"},{"title":"fabric测试工具Caliper的安装配置使用","text":"一、Caliper性能测试工具的配置和使用 （1）下载并配置node.js由于服务器上已经配置完成node.js,所以只需要再检查一遍即可。 12node -vnpm -v 返回版本号即配置成功。 （2）创建并初始化Fabric网络由于服务器上已经下载过fabric-sample和fabric2.2.3二进制文件和镜像，所以只需要进行初始化网络即可。 123cd test-network./network.sh up createChannel./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go 通过以上代码完成初始化设置 （3）创建Caliper工作区回到fabric-sample的同一级目录，在同级目录上创建一个名为caliper-workerspace的文件夹，在该文件夹下创建三个名为networks、benchmarks和workload的文件夹。 123456cd ../..mkdir caliper-workspacecd caliper-workspacemkdir networksmkdir benchmarksmkdir workload 然后，在caliper-workspace目录中，安装caliper cli: 1npm install --only=prod @hyperledger/caliper-cli@0.4.0 使用以下终端命令绑定SDK: 1npx caliper bind --caliper-bind-sut fabric:2.1 （4）构建网络配置文件在networks文件夹下创建一个名为networkConfig.json的文件 12cd networkstouch networkConfig.json 将以下内容复制到该文件中并保存： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465{ &quot;version&quot; : &quot;1.0&quot;, &quot;name&quot;: &quot;Caliper test&quot;, &quot;caliper&quot; : { &quot;blockchain&quot;: &quot;fabric&quot; }, &quot;clients&quot;: { &quot;Admin@org1.example.com&quot;: { &quot;client&quot;: { &quot;credentialStore&quot;: { &quot;path&quot;: &quot;/tmp/org1&quot;, &quot;cryptoStore&quot;: { &quot;path&quot;: &quot;/tmp/org1&quot; } }, &quot;organization&quot;: &quot;Org1&quot;, &quot;clientPrivateKey&quot;: { &quot;path&quot;: &quot;../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/priv_sk&quot; }, &quot;clientSignedCert&quot;: { &quot;path&quot;: &quot;../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/Admin@org1.example.com-cert.pem&quot; }, &quot;connection&quot;: { &quot;timeout&quot;: { &quot;peer&quot;: { &quot;endorser&quot;: &quot;300&quot; } } } } } }, &quot;channels&quot;: { &quot;mychannel&quot;: { &quot;created&quot; : true, &quot;contracts&quot;: [ { &quot;id&quot;:&quot;basic&quot;, &quot;version&quot;:&quot;1.0.0&quot; } ] } }, &quot;organizations&quot;:{ &quot;Org1&quot;: { &quot;mspid&quot;: &quot;Org1MSP&quot;, &quot;peers&quot;: [ &quot;peer0.org1.example.com&quot; ] } }, &quot;peers&quot;: { &quot;peer0.org1.example.com&quot;: { &quot;url&quot;: &quot;grpcs://localhost:7051&quot;, &quot;tlsCACerts&quot;: { &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\n&lt;UNIQUE CONTENT&gt;\\n-----END CERTIFICATE-----\\n&quot; }, &quot;grpcOptions&quot;: { &quot;ssl-target-name-override&quot;: &quot;peer0.org1.example.com&quot;, &quot;hostnameOverride&quot;: &quot;peer0.org1.example.com&quot; } } }} 需要将下面的内容进行替换，需要更具自己网络中生成的证书内容进行更改： 查看方式如下： 1cd /home/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com 打开connection-org1.json，复制该文件中”pem”后面的内容，对networkConfig.json文件中的内容进行替换。 （5）构建测试工作负载模块123cd ..cd workloadtouch readAsset.js 将以下内容复制到该文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'use strict';const { WorkloadModuleBase } = require('@hyperledger/caliper-core');class MyWorkload extends WorkloadModuleBase { constructor() { super(); } async initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext) { await super.initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext); for (let i=0; i&lt;this.roundArguments.assets; i++) { const assetID = `${this.workerIndex}_${i}`; console.log(`Worker ${this.workerIndex}: Creating asset ${assetID}`); const request = { contractId: this.roundArguments.contractId, contractFunction: 'CreateAsset', invokerIdentity: 'Admin@org1.example.com', contractArguments: [assetID,'blue','20','penguin','500'], readOnly: false }; await this.sutAdapter.sendRequests(request); } } async submitTransaction() { const randomId = Math.floor(Math.random()*this.roundArguments.assets); const myArgs = { contractId: this.roundArguments.contractId, contractFunction: 'ReadAsset', invokerIdentity: 'Admin@org1.example.com', contractArguments: [`${this.workerIndex}_${randomId}`], readOnly: true }; await this.sutAdapter.sendRequests(myArgs); } async cleanupWorkloadModule() { for (let i=0; i&lt;this.roundArguments.assets; i++) { const assetID = `${this.workerIndex}_${i}`; console.log(`Worker ${this.workerIndex}: Deleting asset ${assetID}`); const request = { contractId: this.roundArguments.contractId, contractFunction: 'DeleteAsset', invokerIdentity: 'Admin@org1.example.com', contractArguments: [assetID], readOnly: false }; await this.sutAdapter.sendRequests(request); } }}function createWorkloadModule() { return new MyWorkload();}module.exports.createWorkloadModule = createWorkloadModule; （6）构建基准测试配置文件在benchmarks文件夹下创建一个名为myAssetBenchmark.yaml的文件 123cd ..cd benchmarkstouch myAssetBenchmark.yaml 将以下内容复制到myAssetBenchmark.yaml的文件中并保存: 1234567891011121314151617181920212223242526test: name: basic-contract-benchmark description: test benchmark workers: type: local number: 2 rounds: - label: readAsset description: Read asset benchmark txDuration: 30 rateControl: type: fixed-load opts: transactionLoad: 2 workload: module: workload/readAsset.js arguments: assets: 10 contractId: basicmonitors: resource: - module: docker options: interval: 5 containers: - all （7）运行Caliper基准测试1npx caliper launch manager --caliper-workspace ./ --caliper-networkconfig networks/networkConfig.json --caliper-benchconfig benchmarks/myAssetBenchmark.yaml --caliper-flow-only-test --caliper-fabric-gateway-enabled --caliper-fabric-gateway-discovery 测试结果如下所示： 吞吐量： 计算机资源占用情况： 同时在caliper-workspace目录下生成了一个名为report.html的报告，使用Xftp工具将该文件从服务器上提取出来。","link":"/2022/03/16/fabric%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Caliper%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"},{"title":"Hello World","text":"hexo 使用方法 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/01/hello-world/"},{"title":"hexo d时出现Error Spawn failed 报错解决","text":"运行hexo d命令时报错 12345678FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/usr/local/src/hexo/hanyubolg/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 网上的解决方法：12345678##删除git提交内容文件夹rm -rf .deploy_git/##执行git config --global core.autocrlf false##最后hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 试过很多遍，还是无效。 又看到有人说，是因为网络延迟的问题，当我执行ssh命令时 1$ ssh git@github.com 出现以下信息： 123456789101112131415161718192021@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: POSSIBLE DNS SPOOFING DETECTED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@The RSA host key for github.com has changed,and the key for the corresponding IP address 140.82.113.4is unknown. This could either mean thatDNS SPOOFING is happening or the IP address for the hostand its host key have changed at the same time.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host isSHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s.Please contact your system administrator.Add correct host key in /c/Users/shj/.ssh/known_hosts to get rid of this message.Offending RSA key in /c/Users/shj/.ssh/known_hosts:1RSA host key for github.com has changed and you have requested strict checking.Host key verification failed. 上面这个错误提示意味着连接到的 GitHub 服务器的 RSA 主机密钥（host key）已经改变，可能是由于 DNS 欺骗攻击或 GitHub 服务器的 IP 地址和主机密钥同时更改导致的。 最终的解决方法：我决定重新生成ssh密钥： 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件： 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 找到生成的.ssh文件夹中的id_rsa.pub中的密钥内容，并复制（该文件的地址可以从图中看到） 打开github中SSH and GPG keys页面，将原先的密钥删除，并新建new SSH Key，标题随便填，将复制的内容填入下面的框中，即可生成新的密钥。 然后运行下面两个命令： 12ssh-keygen -R github.comssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts 第一条命令将删除已知主机密钥，第二条命令将从 GitHub 获取新的主机密钥并将其添加到你的已知主机列表中。再次运行以下命令， 1$ ssh git@github.com 运行后出现下面信息： SSH 连接已经成功建立并通过身份验证。然而，由于 GitHub 不提供 shell 访问权限，因此连接被关闭了。这是正常的行为，因为当使用 SSH 连接到 GitHub 时，只能执行特定的 Git 命令，而不能像连接到普通的远程服务器一样执行任意的命令。 之后执行 123hexo cleanhexo ghexo d 就可以正常部署了。","link":"/2023/06/05/hexo%20d%E6%97%B6%E5%87%BA%E7%8E%B0Error%20Spawn%20failed%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"title":"leetcode-二叉树","text":"二叉树 1、二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 12输入：root = [1,null,2,3]输出：[1,2,3] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 示例 4： 12输入：root = [1,2]输出：[1,2] 示例 5： 12输入：root = [1,null,2]输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ 1234567891011121314151617// 递归算法class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preOrder(root, result); return result; } public void preOrder(TreeNode root,List&lt;Integer&gt; result) { if (root == null) { return; } result.add(root.val); preOrder(root.left, result); preOrder(root.right, result); }} 1234567891011121314151617181920212223// 迭代算法class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if(node.right != null) { stack.push(node.right); } if(node.left != null) { stack.push(node.left); } } return result; }} 2、二叉树的后序遍历给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[3,2,1] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 提示： 树中节点的数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ 方案一：递归的方法 1.确定递归函数的返回值，参数 2.确定递归函数的终止条件 3.确定单层递归的逻辑 12345678910111213class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); postorderTraver(root,result); return result; } public void postorderTraver(TreeNode root, List&lt;Integer&gt; result) { if(root == null) return; postorderTraver(root.left,result); postorderTraver(root.right,result); result.add(root.val); }} 迭代法： 1234567891011121314151617181920212223242526272829303132class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); if(node.left != null) { stack.push(node.left); } if(node.right != null) { stack.push(node.right); } } // int firstIndex = 0; // int secondIndex = result.size() - 1; // 使用 size() 方法获取列表的大小 // while (firstIndex &lt; secondIndex) { // Integer temp = result.get(firstIndex); // 使用 get(index) 方法访问列表中的元素 // result.set(firstIndex, result.get(secondIndex)); // 使用 set(index, value) 方法设置列表中的元素 // result.set(secondIndex, temp); // firstIndex++; // secondIndex--; // } Collections.reverse(result); return result; }} 3、二叉树的中序遍历给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[1,3,2] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 12345678910111213class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorderTraver(root,result); return result; } public void inorderTraver(TreeNode root, List&lt;Integer&gt; result) { if (root == null) return; inorderTraver(root.left,result); result.add(root.val); inorderTraver(root.right,result); }} 迭代法： 12345678910111213141516171819202122232425class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); TreeNode cur = root; while (!stack.isEmpty()) { if (cur.left != null) { stack.push(cur.left); cur = cur.left; } else { TreeNode node = stack.pop(); result.add(node.val); if(node.right != null) { stack.push(node.right); cur = node.right; } } } return result; }} 4、二叉树的统一迭代法12345678910111213141516171819202122232425262728 // 非递归前序遍历，统一迭代法class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return result; stack.push(root); while(!stack.isEmpty()){ TreeNode tmp = stack.peek(); if (tmp != null){ stack.pop(); if(tmp.right != null){ stack.push(tmp.right); } if(tmp.left != null){ stack.push(tmp.left); } stack.push(tmp); stack.push(null); }else { stack.pop(); TreeNode target = stack.pop(); result.add(target.val); } } return result; }} 1234567891011121314151617181920212223242526272829// 非递归中序遍历，统一迭代法class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return result; stack.push(root); while (!stack.isEmpty()) { TreeNode temp = stack.peek(); if(temp != null){ stack.pop(); if(temp.right != null) { stack.push(temp.right); } stack.push(temp); stack.push(null); if(temp.left !=null) { stack.push(temp.left); } }else { stack.pop(); TreeNode target = stack.pop(); result.add(target.val); } } return result; }} 1234567891011121314151617181920212223242526// 非递归后续遍历，统一迭代法 class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return result; stack.push(root); while(!stack.isEmpty()) { TreeNode temp = stack.peek(); if(temp != null) { stack.push(null); if(temp.right != null) { stack.push(temp.right); } if(temp.left != null) { stack.push(temp.left); } } else { stack.pop(); TreeNode target = stack.pop(); result.add(target.val); } } return result; }} 5、二叉树的层序遍历https://leetcode.cn/problems/binary-tree-level-order-traversal/ 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; treeQue = new LinkedList&lt;TreeNode&gt;(); treeQue.offer(root); while (!treeQue.isEmpty()){ int size = treeQue.size(); List &lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); while(size &gt; 0){ TreeNode item = treeQue.poll(); itemList.add(item.val); if(item.left != null){ treeQue.offer(item.left); } if(item.right != null){ treeQue.offer(item.right); } size--; } result.add(itemList); } return result; }} 一口气打10题： 102.二叉树的层序遍历(opens new window) 107.二叉树的层次遍历II(opens new window) 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 12345678910111213141516171819202122232425262728class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if (root == null) { return result; } Queue &lt;TreeNode&gt; treeQue = new LinkedList&lt;TreeNode&gt;(); treeQue.offer(root); while (!treeQue.isEmpty()) { int size = treeQue.size(); List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); while (size &gt; 0) { TreeNode tmp = treeQue.poll(); itemList.add(tmp.val); if (tmp.left != null) { treeQue.offer(tmp.left); } if (tmp.right != null) { treeQue.offer(tmp.right); } size--; } result.add(0,itemList); } return result; }} 在 Java 的 LinkedList 类中，add(int index, E element) 方法用于在指定位置 index 插入元素 element。当我们使用 result.add(0, itemList);，这意味着我们每次都在 result 列表的开头位置插入一个新的列表 itemList。 下面是这个操作背后的一些底层细节：LinkedList 是一个双向链表。每个元素（或称为节点）都包含三个部分：存储的数据、指向前一个元素的链接和指向下一个元素的链接。在开头插入（index = 0）：当在链表的开始处插入一个新元素时，新元素成为新的头节点。新的头节点的“下一个”链接指向原来的头节点，如果原来的链表不是空的，则原来的头节点的“前一个”链接更新为指向新的头节点。此操作的时间复杂度为 O(1)，因为不需要遍历链表即可完成插入。 更新头尾指针：如果链表原来是空的，则新插入的节点既是头节点也是尾节点。如果链表不是空的，只需更新头节点指针（对于在开头插入的情况） 199.二叉树的右视图(opens new window) 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 12输入: [1,2,3,null,5,null,4]输出: [1,3,4] 示例 2: 12输入: [1,null,3]输出: [1,3] 示例 3: 12输入: []输出: [] 提示: 二叉树的节点个数的范围是 [0,100] -100 &lt;= Node.val &lt;= 100 12345678910111213141516171819202122```- [637.二叉树的层平均值(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)- [429.N叉树的层序遍历(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)- [515.在每个树行中找最大值(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)- [116.填充每个节点的下一个右侧节点指针(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)- [117.填充每个节点的下一个右侧节点指针II(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)- [104.二叉树的最大深度(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)- [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)#### 6、翻转二叉树给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。 **示例 1：**![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg) 输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 12345**示例 2：**![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg) 输入：root = [2,1,3]输出：[2,3,1] 123**示例 3：** 输入：root = []输出：[] 123456789101112131415161718192021222324**提示：**- 树中节点数目范围在 `[0, 100]` 内- `-100 &lt;= Node.val &lt;= 100````java//方案一，递归法（前序、后序都可以）class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return root; } swapTree(root); invertTree(root.left); invertTree(root.right); return root; } public void swapTree(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} 12345678910111213141516171819202122232425262728293031323334//迭代法 （深度优先遍历）统一迭代法class Solution { public TreeNode invertTree(TreeNode root) { if (root == null){ return root; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) { TreeNode temp = stack.peek(); if (temp != null) { stack.pop(); if (temp.right != null) { stack.push(temp.right); } stack.push(temp); stack.push(null); if (temp.left != null) { stack.push(temp.left); } } else { stack.pop(); TreeNode target = stack.pop(); swapTree(target); } } return root; } public void swapTree(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} 12345678910111213141516171819202122232425262728//迭代法 （广度优先遍历即层序遍历）class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return root; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); while(!deque.isEmpty()) { for (int size = deque.size(); size &gt; 0; size--) { TreeNode temp = deque.poll(); swapTree(temp); if (temp.left != null) { deque.offer(temp.left); } if (temp.right != null) { deque.offer(temp.right); } } } return root; } public void swapTree(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} 7、对称二叉树给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root = [1,2,2,null,3,null,3]输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 1234567891011121314151617181920212223242526// 递归法class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return compare(root.left,root.right); } public boolean compare(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right != null) { return false; } if (left != null &amp;&amp; right == null) { return false; } if (left == null &amp;&amp; right == null) { return true; } if (left.val != right.val) { return false; } boolean outside = compare(left.left,right.right); boolean inside = compare(left.right,right.left); return outside &amp;&amp; inside; }} 1234567891011121314151617181920212223242526272829303132// 迭代法class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } Deque &lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root.left); deque.offer(root.right); while(!deque.isEmpty()) { TreeNode right = deque.poll(); TreeNode left = deque.poll(); if(right == null &amp;&amp; left != null) { return false; } if(right != null &amp;&amp; left == null) { return false; } if(right == null &amp;&amp; left == null) { continue; } if(right.val != left.val) { return false; } deque.offer(left.left); deque.offer(right.right); deque.offer(left.right); deque.offer(right.left); } return true; }} 两道相似的题： 100.相同的树(opens new window) 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 12输入：p = [1,2,3], q = [1,2,3]输出：true 示例 2： 12输入：p = [1,2], q = [1,null,2]输出：false 示例 3： 12输入：p = [1,2,1], q = [1,1,2]输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -10^4 &lt;= Node.val &lt;= 10^4 1234567891011121314151617181920//递归法class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q != null) { return false; } if (p != null &amp;&amp; q == null) { return false; } if (p == null &amp;&amp; q == null) { return true; } if (p.val != q.val) { return false; } boolean left = isSameTree(p.left,q.left); boolean right = isSameTree(p.right,q.right); return left &amp;&amp; right; }} 1234567891011121314151617181920212223242526272829303132//递归法class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } Deque &lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(p); deque.offer(q); while(!deque.isEmpty()) { TreeNode rightTree = deque.poll(); TreeNode leftTree = deque.poll(); if (rightTree == null &amp;&amp; leftTree !=null) { return false; } if (rightTree != null &amp;&amp; leftTree == null) { return false; } if (rightTree == null &amp;&amp; leftTree == null) { continue; } if (rightTree.val != leftTree.val) { return false; } deque.offer(rightTree.left); deque.offer(leftTree.left); deque.offer(rightTree.right); deque.offer(leftTree.right); } return true; } 572.另一个树的子树 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。 二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。 示例 1： 12输入：root = [3,4,5,1,2], subRoot = [4,1,2]输出：true 示例 2： 12输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]输出：false 提示： root 树上的节点数量范围是 [1, 2000] subRoot 树上的节点数量范围是 [1, 1000] -104 &lt;= root.val &lt;= 104 -104 &lt;= subRoot.val &lt;= 104 12345678910111213141516171819202122232425262728class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { if (root == null) { return false; } if (isSametree(root,subRoot)) { return true; } return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot); } public boolean isSametree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } if (p.val != q.val) { return false; } boolean left = isSametree(p.left,q.left); boolean right = isSametree(p.right,q.right); return left &amp;&amp; right; }} 1//有一种树哈希的算法 1//转化为字符串序列 用kmp算法 8、二叉树的最大深度给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：3 示例 2： 12输入：root = [1,null,2]输出：2 提示： 树中节点的数量在 [0, 104] 区间内。 -100 &lt;= Node.val &lt;= 100 123456789class Solution { public int maxDepth(TreeNode root) { int depth = 0; if (root == null) { return 0; } return Math.max(maxDepth(root.left)+1,maxDepth(root.right)+1); }} 559.n叉树的最大深度(opens new window) 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 示例 1： 12输入：root = [1,null,3,2,4,null,5,6]输出：3 示例 2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：5 提示： 树的深度不会超过 1000 。 树的节点数目位于 [0, 104] 之间。 12345678910111213class Solution { public int maxDepth(Node root) { int depth = 0; if (root == null) { return 0; } for (int i = 0;i&lt;root.children.size();i++) { depth = Math.max(depth,maxDepth(root.children.get(i))); } return depth+1; }} 9、二叉树的最小深度力扣题目链接 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：2 示例 2： 12输入：root = [2,null,3,null,4,null,5,null,6]输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 123456789101112131415161718192021222324252627// 层序遍历class Solution { public int minDepth(TreeNode root) { int depth = 0 ; if (root == null) { return depth; } Deque &lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); while (!deque.isEmpty()) { depth++; for (int i = deque.size(); i &gt; 0 ; i--) { TreeNode tmp = deque.poll(); if (tmp.left != null) { deque.offer(tmp.left); } if (tmp.right != null) { deque.offer(tmp.right); } if(tmp.left == null &amp;&amp; tmp.right == null) { return depth; } } } return depth; }} 1234567891011121314151617181920212223class Solution { public int minDepth(TreeNode root) { int depth = 0 ; if (root == null) { return 0; } int left = minDepth(root.left); int right = minDepth(root.right); if (root.left == null) { depth = right+1; } if (root.right == null) { depth = left+1; } if (root.left == null &amp;&amp; root.right == null) { depth = 1 ; } if (root.left != null &amp;&amp; root.right != null) { depth = Math.min(left,right)+1; } return depth; }} 10、完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 1： 12输入：root = [1,2,3,4,5,6]输出：6 示例 2： 12输入：root = []输出：0 示例 3： 12输入：root = [1]输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？ 123456789101112class Solution { public int countNodes(TreeNode root) { int node = 0; if (root == null) { return 0 ; } int left = countNodes(root.left); int right = countNodes(root.right); node = left + right + 1; return node; }} 1234567891011121314151617181920212223242526class Solution { public int countNodes(TreeNode root) { int result = 0; if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()){ int size = queue.size(); while (size &gt; 0) { TreeNode tmp = queue.poll(); result++; size--; if (tmp.left != null) { queue.offer(tmp.left); } if (tmp.right != null) { queue.offer(tmp.right); } } } return result; }} 1234567891011121314151617181920212223class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } int leftdepth = 0; int rightdepth = 0; TreeNode tmp = root; while (tmp.right != null) { rightdepth++; tmp = tmp.right; } tmp = root; while (tmp.left != null) { leftdepth++; tmp = tmp.left; } if (leftdepth == rightdepth) { return (2&lt;&lt;rightdepth)-1; } return countNodes(root.left)+countNodes(root.right)+1; }} 11、平衡二叉树力扣题目链接 给定一个二叉树，判断它是否是 平衡二叉树 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：true 示例 2： 12输入：root = [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 12输入：root = []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 1234567891011121314151617181920 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } int left = subLength(root.left); int right = subLength(root.right); if (Math.abs(left-right) &gt; 1) { return false; } return isBalanced(root.left) &amp;&amp; isBalanced(root.right); } public int subLength(TreeNode root) { if (root == null) { return 0; } return Math.max(subLength(root.left),subLength(root.right))+1; }} 123456789101112131415161718192021222324class Solution { public boolean isBalanced(TreeNode root) { return getLength(root)==-1 ?false:true; } public int getLength(TreeNode root) { if (root == null) { return 0; } // int result = 0; int leftLength = getLength(root.left); if (leftLength == -1) { return -1; } int rightLength = getLength(root.right); if (rightLength == -1) { return -1; } if (Math.abs(rightLength-leftLength) &gt;1) { return -1; } return Math.max(rightLength,leftLength)+1; }} 12、二叉树的所有路径力扣题目链接 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 12输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 示例 2： 12输入：root = [1]输出：[&quot;1&quot;] 提示： 树中节点的数目在范围 [1, 100] 内 -100 &lt;= Node.val &lt;= 100 1234567891011121314151617181920212223242526272829303132class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (root == null) { return res; } List&lt;Integer&gt; paths = new ArrayList&lt;&gt;(); Backtrace (root,res,paths); return res; } public void Backtrace(TreeNode root,List&lt;String&gt; res,List&lt;Integer&gt; paths) { paths.add(root.val); if (root.left == null &amp;&amp; root.right == null) { StringBuilder sb = new StringBuilder(); for (int i = 0; i&lt;paths.size()-1; i++) { sb.append(paths.get(i)).append(&quot;-&gt;&quot;); } sb.append(paths.get(paths.size()-1)); res.add(sb.toString()); return; } if (root.left != null) { Backtrace(root.left,res,paths); paths.remove(paths.size()-1); } if (root.right != null) { Backtrace(root.right,res,paths); paths.remove(paths.size()-1); } }} 一直往下遍历， 递归的终止条件时遇到左孩子和右孩子都为空，此时将路径转换为字符串并添加到结果列表，然后回溯到上一个节点继续遍历其他子节点。 13、左叶子之和力扣题目链接 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1： 123输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 12输入: root = [1]输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 &lt;= Node.val &lt;= 1000 1234567891011121314151617181920212223// 层序遍历迭代法class Solution { public int sumOfLeftLeaves(TreeNode root) { int sum = 0; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); while (size -- &gt; 0) { TreeNode node = queue.poll(); if (node.left != null) { // 左节点不为空 queue.offer(node.left); if (node.left.left == null &amp;&amp; node.left.right == null){ // 左叶子节点 sum += node.left.val; } } if (node.right != null) queue.offer(node.right); } } return sum; }} 使用层次遍历法，由于不能直接判断本节点是不是左叶子节点，所以需要借助父亲节点进行判断。 12345678910111213class Solution { public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; int leftVal = sumOfLeftLeaves(root.left); int rightVal = sumOfLeftLeaves(root.right); int midVal = 0; if (root.left != null &amp;&amp; root.left.left==null &amp;&amp; root.left.right==null) { midVal += root.left.val; } int result = leftVal + midVal +rightVal; return result; }} 14、找树左下角的值力扣题目链接 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 12输入: root = [2,1,3]输出: 1 示例 2: 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 12345678910111213141516171819202122232425class Solution { public int findBottomLeftValue(TreeNode root) { int result = 0 ; Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) { int length = queue.size(); if (length &gt; 0) { TreeNode tmp = queue.peek(); result = tmp.val; } while (length &gt; 0) { TreeNode tmp = queue.poll(); if (tmp.left != null) { queue.offer(tmp.left); } if (tmp.right != null) { queue.offer(tmp.right); } length--; } } return result; }} 12345678910111213141516171819202122class Solution { private int Deep = -1; private int value = 0; public int findBottomLeftValue(TreeNode root) { value = root.val; findLeftValue(root,0); return value; } public void findLeftValue(TreeNode root,int deep) { if (root ==null) return; if (deep &gt; Deep) { value = root.val; Deep = deep; } if (root.left !=null) { findLeftValue(root.left,deep+1); } if (root.right !=null) { findLeftValue(root.right,deep+1); } }} 通过确定访问的变量是不是处于最大深度的节点来确定。 15、路径总和力扣题目链接 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 12345678910111213141516171819202122class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; targetSum -= root.val; if (root.left == null &amp;&amp; root.right == null) { return targetSum == 0; } if (root.left != null) { boolean leftResult = hasPathSum(root.left,targetSum); if (leftResult) { return true; } } if (root.right != null) { boolean rightResult = hasPathSum(root.right,targetSum); if (rightResult) { return true; } } return false; }} 用目标结果减去节点的值判断是否为0 来确定是否存在具体的路径。 路径综合II https://leetcode.cn/problems/path-sum-ii/ 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 12输入：root = [1,2,3], targetSum = 5输出：[] 示例 3： 12输入：root = [1,2], targetSum = 0输出：[] 提示： 树中节点总数在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); pathFind(root,targetSum,tmp,result); return result; } public void pathFind(TreeNode root, int targetSum,List&lt;Integer&gt; tmp,List&lt;List&lt;Integer&gt;&gt; result) { if (root == null) return; tmp.add(root.val); targetSum -= root.val; if(root.left == null &amp;&amp; root.right == null) { if (targetSum == 0) { // result.add(tmp); result.add(new ArrayList&lt;&gt;(tmp)); } return; } if(root.left != null) { pathFind(root.left,targetSum,tmp,result); tmp.remove(tmp.size()-1); } if(root.right != null) { pathFind(root.right,targetSum,tmp,result); tmp.remove(tmp.size()-1); } }} 关键在于需要创建一个快照，因为直接使用引用的话，后续对tmp的修改会影响result中的数据。 16、从中序与后序遍历序列构建二叉树力扣题目链接 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 示例 2: 12输入：inorder = [-1], postorder = [-1]输出：[-1] 1234567891011121314151617181920212223class Solution { private Map&lt;Integer,Integer&gt;map; public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap&lt;&gt;(); for (int i=0; i&lt;inorder.length; i++) { map.put(inorder[i],i); } TreeNode result = buildTree (inorder,0,inorder.length-1,postorder,0,postorder.length-1); return result; } public TreeNode buildTree(int[] inorder, int inbegin, int inend, int[] postorder, int postbegin, int postend) { if (inbegin &gt; inend || postbegin &gt; postend) { return null; } int rootVal = postorder[postend]; int indexVal = map.get(rootVal); int leftSize = indexVal - inbegin; TreeNode root = new TreeNode(rootVal); root.left = buildTree (inorder,indexVal-leftSize,indexVal-1,postorder,postbegin,postbegin+leftSize-1); root.right = buildTree (inorder,indexVal+1,inend,postorder,postbegin+leftSize,postend-1); return root; }} https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 12输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 示例 2: 12输入: preorder = [-1], inorder = [-1]输出: [-1] 提示: 1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 123456789101112131415161718192021222324class Solution { private Map &lt;Integer,Integer&gt; map; public TreeNode buildTree(int[] preorder, int[] inorder) { map = new HashMap&lt;&gt;(); for (int i=0;i&lt;inorder.length;i++) { map.put(inorder[i],i); } TreeNode result = buildTreeSolution(preorder,0,preorder.length-1,inorder,0,inorder.length-1); return result; } public TreeNode buildTreeSolution (int[] preorder, int preBegin, int preEnd,int[] inorder, int inBegin, int inEnd) { if (preBegin &gt; preEnd || inBegin &gt; inEnd) { return null; } int rootVal = preorder[preBegin]; int indexVal = map.get(rootVal); int leftSize = indexVal - inBegin; TreeNode root = new TreeNode(rootVal); root.left = buildTreeSolution(preorder,preBegin+1,preBegin+leftSize,inorder,inBegin,inBegin+leftSize); root.right = buildTreeSolution(preorder,preBegin+leftSize+1,preEnd,inorder,inBegin+leftSize+1,inEnd); return root; }} 都是以前序或者后序的开头或最后的一个元素 作为中序遍历数组的分界点。 17、最大二叉树给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 *最大二叉树* 。 示例 1： 123456789101112输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示：- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2： 12输入：nums = [3,2,1]输出：[3,null,2,null,1] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 1234567891011121314151617181920212223242526class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { if (nums.length == 0) { return null; } TreeNode result = construct(nums,0,nums.length-1); return result; } public TreeNode construct (int[] nums,int start, int end) { if (start &gt; end) { return null; } int max = nums[start]; int index = start ; for (int i = start; i &lt;= end; i++) { if (nums[i] &gt; max) { max = nums[i]; index = i; } } TreeNode root = new TreeNode(max); root.left = construct(nums,start,index-1); root.right = construct(nums,index+1,end); return root; }} 18、合并二叉树给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例 1： 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 示例 2： 12输入：root1 = [1], root2 = [1,2]输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 1234567891011121314class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null ) { return root2; } if (root2 == null) { return root1; } root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; } 19、二叉搜索树中的搜索给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例 1: 12输入：root = [4,2,7,1,3], val = 2输出：[2,1,3] 示例 2: 12输入：root = [4,2,7,1,3], val = 5输出：[] 提示： 树中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 123456789101112class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null || root.val == val) { return root; } TreeNode left = searchBST(root.left, val); if (left != null) { return left; } return searchBST(root.right, val); }} 20、验证二叉搜索树力扣题目链接 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左 子树 只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 12输入：root = [2,1,3]输出：true 示例 2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 123456789101112131415161718class Solution { private long prev = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } boolean left = isValidBST(root.left); if (!left) { return false; } if (prev &gt;= root.val) { return false; } prev = root.val; boolean right = isValidBST(root.right); return right; }} 123456789101112131415161718192021class Solution { public boolean isValidBST(TreeNode root) { List &lt;Integer&gt; list = new ArrayList&lt;&gt;(); travel(root,list); for(int i = 1; i &lt; list.size(); i++) { if (list.get(i) &lt;= list.get(i-1)) { return false; } } return true; } public void travel(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } travel(root.left,list); list.add(root.val); travel(root.right,list); }} 21、二叉搜索树的最小绝对差力扣题目链接 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例 1： 12输入：root = [4,2,6,1,3]输出：1 示例 2： 12输入：root = [1,0,48,null,null,12,49]输出：1 提示： 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105 12345678910111213141516171819class Solution { private Integer prev = null; private int min = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { travel(root); return min; } public void travel(TreeNode root) { if (root == null) { return; } travel(root.left); if (prev != null) { min = Math.min(min, root.val - prev); } prev = root.val; travel(root.right); }} 22、二叉搜索树中的众数力扣题目链接 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例 1： 12输入：root = [1,null,2,2]输出：[2] 示例 2： 12输入：root = [0]输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 -105 &lt;= Node.val &lt;= 105 123456789101112131415161718192021222324252627282930313233class Solution { private Integer prev = null; private int count = 0; private int maxCount = 0; private List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public int[] findMode(TreeNode root) { travel(root); return result.stream().mapToInt(Integer::intValue).toArray(); } public void travel (TreeNode root) { if (root == null) { return; } travel(root.left); if (prev == null || root.val != prev) { count = 1; } else { count++; } if (count == maxCount) { result.add(root.val); } if (count &gt; maxCount ) { maxCount = count; result.clear(); result.add(root.val); } prev = root.val; travel(root.right); } 23、二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 123输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 123输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 12输入：root = [1,2], p = 1, q = 2输出：1 提示： 树中节点数目在范围 [2, 105] 内。 -109 &lt;= Node.val &lt;= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 1234567891011121314151617class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) { return root; } if (left != null) { return left; } else { return right; } }} 假设我们在一个节点 root 开始搜索 p 和 q： **当前节点是否为 null**：如果当前节点是 null，那显然这个子树中没有 p 和 q，我们返回 null。 **当前节点是否是 p 或 q**：如果当前节点正好是 p 或 q，那么这个节点直接可能是公共祖先，我们返回这个节点。 递归查找左右子树：如果当前节点不是 p 或 q，我们继续在它的左子树和右子树中递归查找 p 和 q。 如果在左子树中找到一个非空结果，说明 p 或 q 在左子树中。 如果在右子树中找到一个非空结果，说明 p 或 q 在右子树中。 如果左右子树都返回非空的结果，说明 p 和 q 分别位于左右子树中，因此当前节点 root 就是它们的最近公共祖先。 如果只有一边返回了非空结果（例如左边有，右边没有），那说明 p 和 q 都位于左子树中，返回左边的结果。 返回值：递归的结果就是我们所要的最近公共祖先。 23、二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 12345678910111213141516// 迭代法class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { while (root != null) { if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) { root = root.left; } else if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) { root = root.right; } else { return root; } } return null; }} 1234567891011121314151617181920class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null) { return null; } if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) { TreeNode left = lowestCommonAncestor (root.left,p,q); if (left != null) { return left; } } if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) { TreeNode right = lowestCommonAncestor(root.right ,p ,q); if (right != null) { return right; } } return root; }} 24、二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例 1： 123输入：root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是： 示例 2： 12输入：root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25] 示例 3： 12输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5] 提示： 树中的节点数将在 [0, 104]的范围内。 -108 &lt;= Node.val &lt;= 108 所有值 Node.val 是 独一无二 的。 -108 &lt;= val &lt;= 108 保证 val 在原始BST中不存在。 1234567891011121314class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (root.val &gt; val) { root.left = insertIntoBST(root.left,val); } if (root.val &lt; val) { root.right = insertIntoBST(root.right,val); } return root; }} 25、删除二叉搜索树中的节点给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 示例 1: 12345输入：root = [5,3,6,2,4,null,7], key = 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2: 123输入: root = [5,3,6,2,4,null,7], key = 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点 示例 3: 12输入: root = [], key = 0输出: [] 提示: 节点数的范围 [0, 104]. -105 &lt;= Node.val &lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 &lt;= key &lt;= 105 进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。 12345678910111213141516171819202122232425262728class Solution { public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return root; } if (root.val == key) { if (root.left == null) { return root.right; } if (root.right == null) { return root.left; } TreeNode cur = root.right; while(cur.left != null) { cur = cur.left; } cur.left = root.left; return root.right; } if (root.val &lt; key) { root.right = deleteNode (root.right,key); } if (root.val &gt; key) { root.left = deleteNode (root.left,key); } return root; }} 26、修剪二叉搜索树给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1： 12输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2] 示例 2： 12输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1] 提示： 树中节点数在范围 [1, 104] 内 0 &lt;= Node.val &lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 &lt;= low &lt;= high &lt;= 104 12345678910111213141516class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if (root == null) { return root; } if (root.val &lt; low) { return trimBST(root.right,low,high); }else if (root.val &gt; high) { return trimBST(root.left,low,high); }else { root.left = trimBST(root.left,low,high); root.right = trimBST(root.right,low,high); return root; } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; }}public class TrimBST { public TreeNode trimBST(TreeNode root, int low, int high) { // 寻找新的根节点，使其在范围内 while (root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)) { if (root.val &lt; low) { root = root.right; } else if (root.val &gt; high) { root = root.left; } } TreeNode current = root; // 修剪左子树 while (current != null) { while (current.left != null &amp;&amp; current.left.val &lt; low) { current.left = current.left.right; } current = current.left; } current = root; // 修剪右子树 while (current != null) { while (current.right != null &amp;&amp; current.right.val &gt; high) { current.right = current.right.left; } current = current.right; } return root; } public static void main(String[] args) { // 示例：构建二叉搜索树 TreeNode root = new TreeNode(3); root.left = new TreeNode(0); root.right = new TreeNode(4); root.left.right = new TreeNode(2); root.left.right.left = new TreeNode(1); // 修剪范围 int low = 1, high = 3; // 修剪二叉搜索树 TrimBST trimmer = new TrimBST(); TreeNode trimmedRoot = trimmer.trimBST(root, low, high); // 输出修剪后的树 printTree(trimmedRoot); } // 辅助函数：按层打印二叉树 private static void printTree(TreeNode root) { if (root == null) return; java.util.Queue&lt;TreeNode&gt; queue = new java.util.LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.print(node.val + &quot; &quot;); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } System.out.println(); }} 27、将有序数组转换为二叉搜索树给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。 示例 1： 123输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2： 123输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 按 严格递增 顺序排列 123456789101112131415class Solution { public TreeNode sortedArrayToBST(int[] nums) { return sortedArrayToBST(nums, 0, nums.length-1); } public TreeNode sortedArrayToBST(int[] nums, int start, int end) { if(start &gt; end) { return null; } int mid = start + (end - start)/2; TreeNode root = new TreeNode(nums[mid]); root.left = sortedArrayToBST(nums,start,mid-1); root.right = sortedArrayToBST(nums,mid+1,end); return root; }} 28、把二叉搜索树转换为累加树给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 示例 1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2： 12输入：root = [0,null,1]输出：[1,null,1] 示例 3： 12输入：root = [1,0,2]输出：[3,3,2] 示例 4： 12输入：root = [3,2,4,1]输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 12345678910111213class Solution { private int sum = 0; public TreeNode convertBST(TreeNode root) { if (root == null) { return root; } convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; }}","link":"/2024/01/29/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"leetcode 哈希表篇","text":"哈希表的一些概念 HashMap 和 HashSet 都是 Java 集合框架的重要组件，它们的主要区别在于以下几个方面： 1.存储方式不同：HashMap 存储的是键值对，将键映射到值，可通过键来访问值；而 HashSet 存储的是唯一值的集合。 2.实现方式不同：HashMap 内部采用的是哈希表数据结构来存储键值对，而 HashSet 采用的是哈希表或者二叉树数据结构来存储唯一值的集合。 3.数据访问方式不同：HashMap 可以通过键来访问对应的值，通过 get() 方法实现；而 HashSet 只能通过迭代器或者 forEach() 方法来遍历元素，没有直接获取单个元素的方法。 4.存储特点不同：HashSet 存储的是唯一的元素集合，不允许存在重复的元素；而 HashMap 存储的是键值对，键是唯一的，而值可以重复。 5.扩容方式不同：HashMap 扩容的时候会重新调整内部存储结构，将所有键值对重新散列到新的存储区域中；而 HashSet 扩容则仅仅只是增加了哈希桶的数量，然后将原有的元素重新分配到新的桶中。 关于HashMap的其他常用方法 put(K key, V value): 将指定的值与此映射中的指定键关联（可选操作）。get(Object key): 返回到指定键所映射的值，或 null（如果此映射包含该键的映射关系）。remove(Object key): 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。containsKey(Object key): 如果此映射包含指定键的映射关系，则返回 true。keySet(): 返回此映射中包含的键的 Set 视图。values(): 返回此映射中包含的值的 Collection 视图。 一、有效的字母异位词力扣题目链接 给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 注意：若 *s* 和 *t* 中每个字符出现的次数都相同，则称 *s* 和 *t* 互为字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 123456789101112131415161718192021class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()){ return false; } Map&lt;Character,Integer&gt; table = new HashMap&lt;Character,Integer&gt;(); for (int i=0 ;i&lt;s.length();i++){ char ch = s.charAt(i); table.put(ch,table.getOrDefault(ch,0)+1); } for (int i=0 ;i&lt;t.length();i++){ char ch = t.charAt(i); table.put(ch,table.getOrDefault(ch,0)-1); if(table.get(ch)&lt;0){ return false; } } return true; }} 二、两个数组的交集力扣题目链接 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Set;class Solution { public int[] intersection(int[] nums1, int[] nums2) { if(nums1 == null || nums1.length==0 || nums2==null || nums2.length==0 ){ return new int[0]; } Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); for (int i : nums1){ set1.add(i); } for(int i : nums2){ if(set1.contains(i)){ set2.add(i); } } int[] result = new int [set2.size()]; int j = 0; for (int i : set2){ result[j++] = i; } return result; }} 注意学习HashSet的用法，在 Java 中，HashSet 是基于 HashMap 实现的，它不允许存储重复的元素。如果尝试向 HashSet 中添加一个已经存在的元素，这个添加操作将会失败，但不会引发任何异常。HashSet 的 add 方法在添加成功时返回 true，如果元素已经存在，则返回 false。 在上述代码中，HashSet 被用于存储 nums1 和 nums2 数组中的元素。由于 HashSet 不存储重复的元素，所以即使 nums1 或 nums2 中包含重复的值，这些值在 HashSet 中只会存储一次。这样，当检查 nums2 中的元素是否存在于 nums1 对应的 HashSet（set1）中时，即使 nums2 中有重复的元素，结果集 resSet 也只会包含不重复的交集元素。 此外，提供另外一种输出方式 1return set2.stream().mapToInt(x -&gt; x).toArray(); 是Java 8中的一行代码，它使用了Java的Stream API和Lambda表达式。这行代码的功能是将一个Integer类型的集合（如Set&lt;Integer&gt;）转换为一个整型数组。下面是这行代码的详细解释： set2.stream()：这会将set2（一个集合）转换为一个流（Stream）。流是Java 8中引入的一个新概念，它允许你以声明性方式处理数据。 .mapToInt(x -&gt; x)：这是一个中间操作，它会将流中的每个元素转换为一个int。x -&gt; x是一个Lambda表达式，表示对流中的每个元素执行的操作。在这里，它实际上是一个恒等函数，因为它返回的值与输入的值相同。 .toArray()：这是一个终端操作，它会收集流中的所有元素，并将它们放入一个数组中。 所以，这行代码的总体效果是将set2中的所有元素收集到一个整型数组中，并返回这个数组。 三、快乐数力扣题目链接 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 1234567输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 示例 2： 12输入：n = 2输出：false 提示： 1 &lt;= n &lt;= 2^31 - 1 123456789101112131415161718192021222324class Solution { public boolean isHappy(int n) { Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); while(n!=1 &amp;&amp; !set1.contains(n)){ set1.add(n); n = getNextNum(n); } if(n==1){ return true; }else{ return false; } } public int getNextNum(int n){ int result=0; while(n!=0){ int num = n%10; result += num * num; n = n/10; } return result; }} 四、两数之和力扣题目链接 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 123456789101112131415161718192021class Solution { public int[] twoSum(int[] nums, int target) { int [] res = new int [2]; if(nums==null || nums.length==0){ return res; } Map&lt;Integer,Integer&gt; result = new HashMap&lt;&gt;(); for (int i = 0 ;i&lt;nums.length;i++){ int tmp = target - nums[i]; if(result.containsKey(tmp)){ res[0] = i; res[1] = result.get(tmp); return res; } else{ result.put(nums[i],i); } } return res; }} 五、四数相加2力扣题目链接 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 1： 123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示： n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 &lt;= n &lt;= 200 -228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228 12345678910111213141516171819202122class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map&lt;Integer,Integer&gt; map1 = new HashMap&lt;&gt;(); int result = 0; for (int i = 0; i &lt; nums1.length ; i++){ for (int j = 0; j &lt; nums2.length ;j++){ int sum = nums1[i] + nums2[j]; map1.put(sum,map1.getOrDefault(sum,0)+1); } } for (int i = 0; i &lt; nums3.length; i++){ for (int j = 0;j &lt; nums4.length; j++){ int sum = 0 - (nums3[i] + nums4[j]); if (map1.containsKey(sum)){ result += map1.get(sum); } } } return result; }} 123456789101112131415161718192021// 代码随想录中较为优雅的写法class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //统计两个数组中的元素之和，同时统计出现的次数，放入map for (int i : nums1) { for (int j : nums2) { int sum = i + j; map.put(sum, map.getOrDefault(sum, 0) + 1); } } //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数 for (int i : nums3) { for (int j : nums4) { res += map.getOrDefault(0 - i - j, 0); } } return res; }} 六、赎金信力扣题目链接 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 1234567891011121314151617181920class Solution { public boolean canConstruct(String ransomNote, String magazine) { Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for (char ch : magazine.toCharArray()){ map.put(ch , map.getOrDefault(ch,0) + 1); } for (char ch : ransomNote.toCharArray()){ if (map.containsKey(ch)){ map.put(ch , map.get(ch)-1); if(map.get(ch) &lt; 0){ return false; } }else{ return false; } } return true; }} 补充一些字符串的用法： 在Java中，遍历字符串通常指的是按顺序访问字符串中的每个字符。由于字符串在Java中被表示为String对象，可以通过几种不同的方式来遍历它们： 使用传统的for循环： 这是最基本的方法，使用字符串的长度和charAt方法来访问每个字符。 12345javaCopy codeString str = &quot;Hello, World!&quot;;for (int i = 0; i &lt; str.length(); i++) { char ch = str.charAt(i); // 处理ch} 使用for-each循环和toCharArray方法： 首先将字符串转换为字符数组，然后使用for-each循环遍历这个数组。 1234javaCopy codeString str = &quot;Hello, World!&quot;;for (char ch : str.toCharArray()) { // 处理ch} 使用Java 8的chars方法： Java 8引入了chars方法，它返回一个IntStream，这是字符的数值表示形式的流。然后可以使用lambda表达式处理每个字符。 12345javaCopy codeString str = &quot;Hello, World!&quot;;str.chars().forEach(c -&gt; { char ch = (char) c; // 处理ch}); 使用Java 8的codePoints方法： 对于需要处理Unicode代理对（即代码点大于U+FFFF的字符）的情况，codePoints方法会更加合适。它返回一个代表字符串中所有代码点的流。 12345javaCopy codeString str = &quot;Hello, World!&quot;;str.codePoints().forEach(cp -&gt; { char[] chars = Character.toChars(cp); // 处理chars}); 在大多数情况下，前两种方法已经足够使用。但是，如果您处理的字符串包含Unicode代理对，或者您想利用流的特性（如并行处理），那么使用chars或codePoints方法可能更合适。 七、三数之和力扣题目链接 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 12345678910111213141516171819202122232425262728293031323334353637// 使用双指针法class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i=0 ;i&lt;nums.length-2;i++){ // 确保在数组中遇到一个与前一个元素相同的元素时，会跳过它，从而避免了重复的三元组。 if (i&gt;0 &amp;&amp; nums[i]==nums[i-1]){ continue; } int left = i+1; int right = nums.length-1; while(left &lt; right){ int sum = nums[i] + nums[left] + nums[right]; if(sum == 0){ result.add(Arrays.asList(nums[i],nums[left],nums[right])); while(left&lt;right&amp;&amp;nums[left]==nums[left+1]){ left++; } while(left&lt;right&amp;&amp;nums[right]==nums[right-1]){ right--; } left++; right--; }else if (sum&lt;0){ left++; }else{ right--; } } } return result; }} 八、四数之和力扣题目链接 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { Long targetNew = (long) target; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums.length&lt;4){ return result; } for(int i = 0; i &lt; nums.length-3; i++){ if (i&gt;0 &amp;&amp;nums[i]==nums[i-1]){ continue; } for(int j = i+1 ;j &lt; nums.length-2; j++){ if((j&gt;i+1)&amp;&amp;(nums[j]==nums[j-1])){ continue; } int left = j+1; int right = nums.length-1; while(left&lt;right){ long sum = (long) nums[i] + nums[j] + nums[left] + nums[right]; if(sum == targetNew){ result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left &lt; right &amp;&amp; nums[left] == nums[left+1]){ left++; } while(left &lt; right &amp;&amp; nums[right] == nums[right-1]){ right--; } left++; right--; }else if(sum &lt; targetNew){ left++; }else{ right--; } } } } return result; }} 其中，有个注意事项是sum超出了 int的最大范围，导致有两个用例没有通过，所以需要进行强制转化。 在Java中，int 类型是一个 32 位的有符号整数类型。其取值范围是从 -2^31 到 2^31 - 1，具体来说： 最小值是 -2,147,483,648 （即 -2^31）。 最大值是 2,147,483,647 （即 2^31 - 1）。 这个范围确保了int类型可以存储的任何整数值都在这个范围内。如果需要更大的数值范围，可以考虑使用long类型，它是一个64位的有符号整数类型，其范围远大于int。 题目中的10^9 其实已经做出了提醒。 九、总结篇","link":"/2024/01/15/leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/"},{"title":"leetcode 字符串篇","text":"代码随想录 字符串篇 一、反转字符串力扣题目链接 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。 示例 1： 12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 提示： 1 &lt;= s.length &lt;= 105 s[i] 都是 ASCII 码表中的可打印字符 1234567891011121314class Solution { public void reverseString(char[] s) { // 注意到虽然是字符串翻转，但传入的值是数组，补充字符串变数组的库函数 toCharArray int left = 0 , right = s.length - 1; while(left &lt; right){ char tmp = s[left]; s[left] = s[right]; s[right] = tmp; left++; right--; } }} 二、反转字符串2力扣题目链接 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot; 示例 2： 12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 10^4 s 仅由小写英文组成 1 &lt;= k &lt;= 10^4 12345678910111213141516171819202122class Solution { public String reverseStr(String s, int k) { char [] ch = s.toCharArray(); for (int i = 0; i &lt; ch.length; i+=2*k){ int start = i; int end = Math.min(ch.length-1 , start+k-1); // 新学到方法，通过异或运算实现两个内容的交换 while(start&lt;end){ ch[start] ^= ch[end]; ch[end] ^= ch[start]; ch[start] ^= ch[end]; start++; end--; } } // 使用String类的valueOf方法 return String.valueOf(ch); // 第二种输出方式，char类型的数组怎么转换成对应的字符串 // return new String(ch); }} 借此契机，学习StringBuffer的知识，下面的解题方法也来自于代码随想录， 12345678910111213141516171819202122232425class Solution { public String reverseStr(String s, int k) { StringBuffer res = new StringBuffer(); int length = s.length(); int start = 0; while (start &lt; length) { // 找到k处和2k处 StringBuffer temp = new StringBuffer(); // 与length进行判断，如果大于length了，那就将其置为length int firstK = (start + k &gt; length) ? length : start + k; int secondK = (start + (2 * k) &gt; length) ? length : start + (2 * k); //无论start所处位置，至少会反转一次 temp.append(s.substring(start, firstK)); res.append(temp.reverse()); // 如果firstK到secondK之间有元素，这些元素直接放入res里即可。 if (firstK &lt; secondK) { //此时剩余长度一定大于k。 res.append(s.substring(firstK, secondK)); } start += (2 * k); } return res.toString(); }} 三、替换数字四、翻转字符串里的单词五、右旋转字符串六、实现strStr()七、重复的子字符串八、总结篇","link":"/2024/01/17/leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/"},{"title":"leetcode 栈与队列","text":"栈与队列 java中栈与队列的所有常用的实现方法1.用栈实现队列力扣题目链接 2.用队列实现栈力扣题目链接 3.有效的括号力扣题目链接 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]{}&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 '()[]{}' 组成 1234567891011121314151617181920212223242526class Solution { public boolean isValid(String s) { Deque &lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++){ char ch = s.charAt(i); if(ch == '('){ stack.push(')'); }else if (ch == '['){ stack.push(']'); }else if (ch == '{'){ stack.push('}'); }else { if (stack.isEmpty() ||stack.peek()!=ch){ return false; }else{ stack.pop(); } } } if (stack.isEmpty()){ return true; } else { return false; } }} 4.删除字符串中的所有相邻重复项力扣题目链接 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 1234输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。 提示： 1 &lt;= S.length &lt;= 20000 S 仅由小写英文字母组成。 123456789101112131415161718192021class Solution { public String removeDuplicates(String s) { ArrayDeque &lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char ch = s.charAt(i); if (stack.isEmpty() || stack.peek()!=ch) { stack.push(ch); } else { stack.pop(); } } String result = &quot;&quot;; while(!stack.isEmpty()) { result = stack.pop()+result; // result = stack.peek() + result; // stack.pop(); } return result; }} 5.逆波兰表达式求值6.滑动窗口最大值7.前k个高频元素8.总结篇","link":"/2024/01/18/leetcode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"title":"leetcode 链表篇","text":"链表篇 链表的java写法12345678910111213141516171819202122public class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; }} 一、移除链表元素力扣题目链接 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 12345678910方法一：递归法class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null){ return null; } head.next = removeElements(head.next,val); return head.val==val?head.next:head; }} 123456789101112131415161718192021方法二：迭代法class Solution { public ListNode removeElements(ListNode head, int val) { // if (head == null){ // return null; // } // head.next = removeElements(head.next,val); // return head.val==val?head.next:head; ListNode dummyNode = new ListNode(val-1); dummyNode.next = head; ListNode tmp = dummyNode; while (tmp.next != null){ if (tmp.next.val==val){ tmp.next = tmp.next.next; }else{ tmp = tmp.next; } } return dummyNode.next; }} 二、设计链表力扣题目链接 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例： 1234567891011121314输入[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2); // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1); // 返回 2myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-&gt;3myLinkedList.get(1); // 返回 3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class MyLinkedList { ListNode head; int size = 0; private class ListNode { int val; ListNode next; ListNode(int val){ this.val = val; } } public MyLinkedList() { this.head = new ListNode(0); this.size = 0; } public int get(int index) { if(index&lt;0||index&gt;=size){ return -1; }else{ ListNode currentNode = head; for (int i=0;i&lt;=index;i++){ currentNode = currentNode.next; } return currentNode.val; } } public void addAtHead(int val) { addAtIndex(0,val); } public void addAtTail(int val) { addAtIndex(size,val); } public void addAtIndex(int index, int val) { if (index &gt; size) { return; } if (index &lt; 0) { index =0; } size++; ListNode currentNode = head; ListNode pre = head; ListNode addNode = new ListNode(val); for(int i=0 ;i&lt;=index;i++){ pre = currentNode; currentNode = currentNode.next; } pre.next = addNode; addNode.next = currentNode; } public void deleteAtIndex(int index) { if (index&lt;0||index&gt;=size){ return; } size--; ListNode currentNode = head; for(int i=0;i&lt;index;i++){ currentNode = currentNode.next; } if(currentNode.next!=null){ currentNode.next = currentNode.next.next; } }}/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ 三、翻转链表力扣题目链接 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 1234567891011121314151.双指针法：class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cru = head; ListNode tmp = null; while (cru!=null){ tmp = cru.next; cru.next = pre; pre = cru; cru = tmp; } return pre; }} 双指针法的代码很少，但其中的细节特别多，首先是初始化部分，cru为头节点，pre为空 12345678910111213141516171819202122232425262728293031323334353637递归的方法：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseList(ListNode head) { // 1.双指针 // ListNode pre = null; // ListNode cru = head; // ListNode tmp = null; // while (cru!=null){ // tmp = cru.next; // cru.next = pre; // pre = cru; // cru = tmp; // } // return pre; if(head==null){ return null; } if(head.next==null){ return head; } ListNode newHead = reverseList(head.next); head.next.next = head; head.next =null; return newHead; }} 不需要清楚递归的细节是怎么实现的，只需要知道它返回的链表已经是翻转结束的。可以这么理解：1 -&gt; 2 &lt;-3 &lt;- 4 &lt;- 5： 2 3 4 5已经翻转完成，但1的next依然是指向2的，只要让2的next指向1，1再指向null就完成了。 四、两两交换链表中的节点力扣题目链接 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head = []输出：[] 示例 3： 12输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 1234567891011121314151617181920212223242526272829方法一：递归法，时间复杂度是On 空间复杂度也是On/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { if(head==null){ return null; } if(head.next == null){ return head; } ListNode part = swapPairs(head.next.next); ListNode second = head.next; second.next = head; head.next = part; // 返回新的头节点，即原来的第二个节点 return second; }} 12345678910111213141516171819202122232425262728293031方法二：模拟法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode temp ; //用于记录第三个节点后的内容 ListNode dumyhead = new ListNode();//虚拟头节点 dumyhead.next = head; ListNode cul = dumyhead; ListNode firstnode ; ListNode secondnode; while(cul.next!=null&amp;&amp;cul.next.next!=null){ firstnode = cul.next; secondnode = cul.next.next; temp = cul.next.next.next; cul.next = secondnode; secondnode.next = firstnode; firstnode.next = temp; cul = firstnode; } return dumyhead.next; }} 五、删除链表的倒数第N个节点力扣题目链接 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ 12345678910111213141516171819class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fastIndex ; ListNode slowIndex = new ListNode(); fastIndex = head; slowIndex.next = head; ListNode cur = slowIndex; for (int i = 1 ;i &lt;= n ;i++){ fastIndex = fastIndex.next; } while(fastIndex !=null){ fastIndex = fastIndex.next; slowIndex = slowIndex.next; } slowIndex.next = slowIndex.next.next; return cur.next; }} 六、链表相交力扣题目链接 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 有三种方法： 1.hash集合 123456789101112131415161718public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;(); ListNode temp = headA; while (temp!=null){ visited.add(temp); temp = temp.next; } temp = headB; while(temp!=null){ if(visited.contains(temp)){ return temp; } temp=temp.next; } return null; }} 时间复杂度：O(m+n)其中 m 和 n是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。 空间复杂度：O(m)，其中 m 是链表 headA的长度。需要使用哈希集合存储链表 headA中的全部节点。 2.数学方法： 12345678910111213141516171819202122public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA==null || headB==null){ return null; } ListNode tempA = headA; ListNode tempB = headB; while(tempA!=tempB){ if (tempA==null){ tempA = headB; }else { tempA = tempA.next; } if (tempB==null){ tempB = headA; }else { tempB = tempB.next; } } return tempA; }} 时间复杂度：O(m+n)，其中 m和 n 是分别是链表 headA和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。 空间复杂度：O(1)。 3.尾部对齐： 123456789101112131415161718192021222324252627282930313233343536373839public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int lengthA = 0; int lengthB = 0; int gap =0; ListNode tempA = headA; ListNode tempB = headB; while(tempA!=null){ tempA = tempA.next; lengthA++; } while(tempB!=null){ tempB = tempB.next; lengthB++; } if(lengthA&gt;=lengthB){ tempA=headA; tempB=headB; gap = lengthA-lengthB; }else{ tempA=headB; tempB=headA; gap = lengthB-lengthA; } for(int i=1;i&lt;=gap;i++){ tempA=tempA.next; } while(tempA!=null){ if(tempA==tempB){ return tempA; }else{ tempA=tempA.next; tempB=tempB.next; } } return null; }} 七、环形链表2力扣题目链接 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？ 12345678910111213141516方法一：HashSet的方法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode pos = head; Set&lt;ListNode&gt; result = new HashSet&lt;ListNode&gt;(); while(pos!=null){ if(result.contains(pos)){ return pos; }else{ result.add(pos); pos = pos.next; } } return null; }} 时间复杂度：O(N)，其中 N 为链表中节点的数目。恰好需要访问链表中的每一个节点。 空间复杂度：O(N)，其中 N 为链表中节点的数目。需要将链表中的每个节点都保存在哈希表当中。 1234567891011121314151617181920// 方法二：数学推导，快指针每次前进2个节点，慢指针每次前进1个节点，public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null){ fast = fast.next.next; slow = slow.next; if(fast==slow){ fast = head; while(fast!=slow){ fast = fast.next; slow = slow.next; } return fast; } } return null; }} 八、总结篇","link":"/2024/01/11/leetcode-%E9%93%BE%E8%A1%A8%E7%AF%87/"},{"title":"leetcode算法","text":"蹉跎良久，终于开始刷题 2023年，研一上修了高级算法与设计，对贪心，分治，动态规划，网络流，np问题，npc问题（规约），近似算法有了一定的了解。 以上只是算法层面，真正实际代码层面，并没有经过一个完整的过程。期间刷过一段时间，但后面又耽搁了。还有一年的时间，将时间段定在寒假结束之前，看这段时间能不能按照代码随想录的顺序完整地刷一遍算法，然后将过程心得记录下来，不管题目是多简单或者多难，将方法，思想，注释完善下。 一、数组引入： 二维数组在内存的空间地址是连续的么？ 不同的编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的，下面是代码随想录提供的测试实验： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void test_arr() { int array[2][3] = { {0, 1, 2}, {3, 4, 5} }; // 打印每个元素的地址 cout &lt;&lt; &amp;array[0][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][2] &lt;&lt; endl; cout &lt;&lt; &amp;array[1][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][2] &lt;&lt; endl;}int main() { test_arr(); return 0;} 运行结果如下： 可以看出地址是16进制，并且相邻两个数组元素相差4个字节（int占用4个字节） 题外话： Q：一个字等于多少个字节？ A：与系统硬件（总线、cpu命令字位数等）有关，不应该毫无前提地说一个字等于多少位。 正确的说法： ①：1字节（byte） = 8位（bit） ②：在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit） ​ 在32位的系统中（比如win32） 1字（word）= 4字节（byte）=32（bit） ​ 在64位的系统中（比如win64）1字（word）= 8字节（byte）=64（bit） JAVA: Java 与 C++ 在内存管理和对程序员的暴露程度上的不同。在 Java 中，指针的概念被隐藏，而且程序员通常无法直接访问或操作对象的内存地址,寻址操作完全交给虚拟机。这是 Java 设计的一部分，旨在提供更安全的编程环境。 123456789101112131415161718public class test1 { public static void main(String[] args) { test_arr(); } public static void test_arr() { int[][] arr = {{1, 2, 3}, {3, 4, 5}, {6, 7, 8}, {9, 9, 9}}; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); // 新的一行 System.out.print(arr[i] + &quot; &quot;); System.out.println(); // 新的一行 } }} 运行结果如下： 当尝试打印一个数组对象（如 arr[0]），Java 默认打印对象的引用地址，通常是一个哈希码或者一种内部表示，而不是内存中的具体地址。这是因为 Java 的安全性和抽象层次，它隐藏了底层的内存管理细节。 如果想查看数组中各个元素的值，需要遍历数组并打印每个元素，而不是直接打印数组对象本身。 二、数组Leetcode题1. 二分查找https://leetcode.cn/problems/search-insert-position/ 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 12345678910111213141516171819202122class Solution { public int search(int[] nums, int target) { if (target &lt; nums[0]||target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left&lt;=right){ int mid = left + ((right-left)&gt;&gt;2); if (nums[mid]&gt;target){ right = mid-1; } else if(nums[mid]&lt;target){ left = mid+1; } else { return mid; } } return -1; }} 有些公司的算法题可能会是acm输入输出模式的，现提供手动输入输出版本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Scanner;public class Solution704 { public int search(int[] nums, int target) { if (target &lt; nums[0]||target &gt; nums[nums.length-1]){ return -1; } int left = 0; int right = nums.length-1; while (left&lt;=right){ int mid = left + ((right-left)&gt;&gt;2); if (nums[mid]&gt;target){ right = mid-1; } else if(nums[mid]&lt;target){ left = mid+1; } else { return mid; } } return -1; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入数组的长度:&quot;); int n = scanner.nextInt(); int[] nums = new int[n]; System.out.println(&quot;请输入 &quot; + n + &quot; 个升序整数:&quot;); for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); } System.out.println(&quot;请输入目标值:&quot;); int target = scanner.nextInt(); Solution704 solution = new Solution704(); int result = solution.search(nums, target); if (result != -1) { System.out.println(&quot;元素 &quot; + target + &quot; 的索引为: &quot; + result); } else { System.out.println(&quot;元素 &quot; + target + &quot; 不在数组中&quot;); } scanner.close(); }} 如果不想要限制输入数据长度，可以采用可变数组的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;import java.util.Scanner;public class BinarySearchWithArrayList { public static int search(ArrayList&lt;Integer&gt; nums, int target) { int left = 0; int right = nums.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums.get(mid) == target) { return mid; } else if (nums.get(mid) &lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); System.out.println(&quot;请输入升序整数（输入非数字字符结束输入）:&quot;); // 循环读取整数，直到非数字输入 while (scanner.hasNextInt()) { nums.add(scanner.nextInt()); } System.out.println(&quot;请输入目标值:&quot;); scanner.nextLine(); // 清除输入流中的非数字字符 int target = scanner.nextInt(); int result = search(nums, target); if (result != -1) { System.out.println(&quot;元素 &quot; + target + &quot; 的索引为: &quot; + result); } else { System.out.println(&quot;元素 &quot; + target + &quot; 不在数组中&quot;); } scanner.close(); }} 相似题目： 35.搜索插入位置(opens new window) 34.在排序数组中查找元素的第一个和最后一个位置(opens new window) 69.x 的平方根(opens new window) 367.有效的完全平方数 35.搜索插入位置 34.在排序数组中查找元素的第一个和最后一个位置 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 123456789101112```**367.有效的完全平方数**给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。不能使用任何内置的库函数，如 `sqrt` 。**示例 1：** 输入：num = 16输出：true解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 123**示例 2：** 输入：num = 14输出：false解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 1234567891011121314151617181920212223242526272829**提示：**- `1 &lt;= num &lt;= 2^31 - 1````javaclass Solution { public boolean isPerfectSquare(int num) { if(num &lt; 2){ return true; } long left = 2; long right = num/2; while(left&lt;=right){ long mid = left + ((right-left)&gt;&gt;1); long square = mid * mid; if (square &gt; num){ right = mid-1; } else if (square &lt; num){ left = mid+1; } else { return true; } } return false; }} 123456789101112131415161718192021222324252627public class Solution367 { public boolean isPerfectSquare(int num) { if (num &lt; 2) { return true; } long left = 2; long right = num / 2; while (left &lt;= right) { long mid = left + ((right - left) &gt;&gt; 1); long square = mid * mid; if (square &gt; num) { right = mid - 1; } else if (square &lt; num) { left = mid + 1; } else { return true; } } return false; } public static void main(String[] args) { Solution367 solution = new Solution367(); boolean result = solution.isPerfectSquare(808201); System.out.println(result); }} int 类型在 Java 中是一个 32 位的有符号整数类型。其取值范围从 -2,147,483,648（即 -2^31）到 2,147,483,647（即 2^31 - 1）。这意味着 int 类型可以存储的最大正整数是 2,147,483,647。 虽然 int 类型的最大值是 2,147,483,647，这确实足够大，但是代码中，当计算 mid * mid 时，即使 mid 本身是一个有效的 int 值，乘积仍然可能超过 int 类型的最大值。 举个例子，假设 mid 是 50,000，那么 mid * mid 将是 2,500,000,000，这个值已经超出了 int 类型的最大范围（2,147,483,647）。这就是为什么在计算平方时可能发生溢出的原因。 为了避免这个问题，我们需要使用一个更大的数据类型来存储平方的结果。在 Java 中，long 类型是一个 64 位的整数，它的最大值远大于 int，所以使用 long 类型可以防止在计算大数平方时发生溢出。 二、移除元素27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,3,0,4]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 123456789101112class Solution { public int removeElement(int[] nums, int val) { int slowIndex = 0; for (int fastIndex = 0;fastIndex &lt; nums.length;fastIndex++){ if (nums[fastIndex] != val){ nums[slowIndex] = nums[fastIndex]; slowIndex++; } } return slowIndex; }} 在使用双指针方法移除数组中的特定元素后，慢指针（在这个例子中是指针 i）之后的元素实际上是不需要关心的。这是因为函数返回的新长度（i 的值）标志着数组有效部分的结束。在这个新长度之后的元素，即便它们仍然存储在数组中，也被视为“无效”或“不可见”。 重要的是要理解，数组的物理大小（即数组能够容纳的元素数量）并没有改变，因为Java数组的大小在创建后是固定的。这个方法只是改变了数组的“有效”大小。 例如，如果原数组是 [3, 2, 2, 3]，val 是 3，那么在调用 removeElement 方法后，数组可能看起来像 [2, 2, 2, 3]，但方法返回的长度是 2。因此，尽管物理上数组中还有四个元素，只有前两个元素（[2, 2]）是有效的或被认为是数组的新内容。 在实际应用中，通常只关心数组的这个“有效”部分。如果需要在某些情况下消除数组剩余部分的混淆，可以选择将其余部分填充为一个特定的值（如零或某个不可能出现的值），但这通常是不必要的。 相似题目： 26.删除排序数组中的重复项(opens new window) 283.移动零(opens new window) 844.比较含退格的字符串(opens new window) 977.有序数组的平方 26. 删除有序数组中的重复项 给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i];} 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非严格递增 排列 123456789101112class Solution { public int removeDuplicates(int[] nums) { int shortIndex = 0; for (int longIndex = 0;longIndex &lt; nums.length;longIndex++){ if(nums[longIndex]!=nums[shortIndex]){ shortIndex++; nums[shortIndex]=nums[longIndex]; } } return shortIndex+1; }} 通过快慢指针的方法，快指针找到第一个与慢指针指向的不同元素，替换慢指针的下一个元素，最后返回慢指针加1； 283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 12输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 示例 2: 12输入: nums = [0]输出: [0] 提示: 1 &lt;= nums.length &lt;= 104 -231 &lt;= nums[i] &lt;= 231 - 1 123456789101112131415class Solution { public void moveZeroes(int[] nums) { int slowIndex = 0; for (int longIndex = 0 ; longIndex &lt; nums.length; longIndex++){ if(nums[longIndex]!=0){ nums[slowIndex]=nums[longIndex]; slowIndex++; } } while(slowIndex&lt;nums.length){ nums[slowIndex]=0; slowIndex++; } }} 844.比较含退格的字符串(opens new window) 三、有序数组的平方977.有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 123456789101112131415161718class Solution { public int[] sortedSquares(int[] nums) { int fastIndex = nums.length-1; int slowIndex = 0; int [] result = new int [nums.length]; int n = nums.length-1; while (fastIndex &gt;= slowIndex){ if(nums[fastIndex]*nums[fastIndex]&gt;=nums[slowIndex]*nums[slowIndex]){ result[n--]=nums[fastIndex]*nums[fastIndex]; fastIndex--; }else{ result[n--]=nums[slowIndex]*nums[slowIndex]; slowIndex++; } } return result; }} 题意中的非递减顺序排列的数组是解题要点，由于由正负数，所以两端的平方肯定有最大数； 四、长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 10^9 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 12345678910111213141516171819202122方法一：o(n)时间复杂度，滑动窗口（快慢指针方法） class Solution { public int minSubArrayLen(int target, int[] nums) { int result = Integer.MAX_VALUE; int shortIndex = 0; int sum = 0; int tag = 0; for (int longIndex = 0;longIndex &lt; nums.length;longIndex++ ){ sum += nums[longIndex]; while(sum&gt;=target){ sum-=nums[shortIndex]; // tag = longIndex-shortIndex+1; // if (tag&lt;=result){ // result = longIndex-shortIndex+1; // } result = Math.min(result,longIndex-shortIndex+1); shortIndex++; } } return result==Integer.MAX_VALUE ? 0 :result; }} 1方法二：o(nlogn)的fang'f 904.水果成篮 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length 12345678910111213141516171819202122class Solution { public int totalFruit(int[] fruits) { Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;(); int maxFruits = 0, left = 0; for (int right = 0; right &lt; fruits.length; right++) { countMap.put(fruits[right], countMap.getOrDefault(fruits[right], 0) + 1); while (countMap.size() &gt; 2) { countMap.put(fruits[left], countMap.get(fruits[left]) - 1); if (countMap.get(fruits[left]) == 0) { countMap.remove(fruits[left]); } left++; } maxFruits = Math.max(maxFruits, right - left + 1); } return maxFruits; }} 76.最小覆盖子串(opens new window) 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 123输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 'A'、'B' 和 'C'。 示例 2： 123输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。 示例 3: 1234输入: s = &quot;a&quot;, t = &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。 提示： m == s.length n == t.length 1 &lt;= m, n &lt;= 105 s 和 t 由英文字母组成 进阶：你能设计一个在 o(m+n) 时间内解决此问题的算法吗？ 1234567891011121314```#### 五、螺旋矩阵II给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。**示例 1：**![img](https://shjpic.oss-cn-chengdu.aliyuncs.com/spiraln.jpg) 输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 123**示例 2：** 输入：n = 1输出：[[1]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647**提示：**- `1 &lt;= n &lt;= 20`第一种方法：模拟```javaclass Solution { public int[][] generateMatrix(int n) { int[][] matrix = new int[n][n]; int num = 1; int startRow = 0, endRow = n - 1; int startCol = 0, endCol = n - 1; while (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol) { // 从左到右填充顶部行 for (int col = startCol; col &lt;= endCol; col++) { matrix[startRow][col] = num++; } startRow++; // 从上到下填充右侧列 for (int row = startRow; row &lt;= endRow; row++) { matrix[row][endCol] = num++; } endCol--; // 从右到左填充底部行 if (startRow &lt;= endRow) { for (int col = endCol; col &gt;= startCol; col--) { matrix[endRow][col] = num++; } endRow--; } // 从下到上填充左侧列 if (startCol &lt;= endCol) { for (int row = endRow; row &gt;= startRow; row--) { matrix[row][startCol] = num++; } startCol++; } } return matrix; }} 相似题目： 54.螺旋矩阵 剑指Offer 29.顺时针打印矩阵 54.螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int startRow = 0, endRow = matrix.length-1; int startCol = 0, endCol = matrix[0].length-1; while (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol ){ for (int col = startCol; col &lt;= endCol; col++){ result.add(matrix[startRow][col]); } startRow++; for (int row = startRow; row &lt;= endRow; row++){ result.add(matrix[row][endCol]); } endCol--; if(startCol&lt;=endCol &amp;&amp; startRow&lt;=endRow){ for (int col = endCol;col &gt;= startCol;col--){ result.add(matrix[endRow][col]); } endRow--; } if(startRow&lt;=endRow &amp;&amp; startCol&lt;=endCol){ for (int row = endRow;row &gt;=startRow;row--){ result.add(matrix[row][startCol]); } startCol++; } } return result; }} 剑指Offer 29.顺时针打印矩阵 给定一个二维数组 array，请返回「螺旋遍历」该数组的结果。 螺旋遍历：从左上角开始，按照 向右、向下、向左、向上 的顺序 依次 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。 示例 1： 12输入：array = [[1,2,3],[8,9,4],[7,6,5]]输出：[1,2,3,4,5,6,7,8,9] 示例 2： 12输入：array = [[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]输出：[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] 限制： 0 &lt;= array.length &lt;= 100 0 &lt;= array[i].length &lt;= 100 12345678910111213141516171819202122232425262728293031323334class Solution { public int[] spiralArray(int[][] array) { if (array.length==0){ return new int[0]; } int [] result = new int[array.length*array[0].length]; int num = 0; int startRow = 0, endRow = array.length-1; int startCol = 0, endCol = array[0].length-1; while (startRow&lt;=endRow &amp;&amp; startCol&lt;=endCol){ for(int col = startCol ; col&lt;=endCol; col++){ result[num++]=array[startRow][col]; } startRow++; for(int row = startRow; row&lt;=endRow; row++){ result[num++]=array[row][endCol]; } endCol--; if(startCol&lt;=endCol &amp;&amp; startRow&lt;=endRow){ for(int col = endCol;col&gt;=startCol;col--){ result[num++]= array[endRow][col]; } endRow--; } if(startRow&lt;=endRow &amp;&amp; startCol&lt;=endCol){ for(int row = endRow;row&gt;=startRow;row--){ result[num++]= array[row][startCol]; } startCol++; } } return result; }} 六、总结篇","link":"/2024/01/02/leetcode%E7%AE%97%E6%B3%95/"},{"title":"创建github仓库","text":"创建github仓库 建立一个GitHub代码仓库并每天提交LeetCode题目的解答是一个很好的练习和记录自己学习进度的方式。以下是具体步骤： 创建GitHub账号：如果你还没有GitHub账号，首先需要在GitHub网站注册一个账号。 创建新的仓库： 登录GitHub账号。 在GitHub页面的右上角，点击 “+” 图标，然后选择 “New repository”。 填写仓库名称（例如：LeetCodeSolutions），可以选择公开或私有仓库。 可以选择初始化仓库，比如添加README文件。 点击 “Create repository”。 在本地电脑设置Git（如果你的电脑上还没有Git）： 下载并安装Git：访问Git官网下载并安装。 配置用户信息：打开Git Bash或命令提示符，输入以下命令： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 将GitHub仓库克隆到本地： 在GitHub仓库页面，找到 “Clone or download”，复制提供的URL。 在本地电脑上选择一个合适的文件夹，右击选择 “Git Bash Here”（或在命令提示符中导航到该文件夹）。 输入以下命令克隆仓库： 1git clone 你复制的URL 添加、提交和推送代码： 在本地仓库文件夹中添加或修改文件（例如，你的LeetCode题解）。 打开Git Bash或命令提示符，切换到仓库文件夹。 使用以下命令将改动添加到本地仓库： 1git add . 提交改动到本地仓库： 1git commit -m &quot;添加了对应的信息，例如完成了某某题目&quot; 将改动推送到GitHub上的仓库： 1git push 每天重复步骤5：每天完成LeetCode题目后，重复步骤5来更新你的GitHub仓库。 通过以上步骤，你就可以建立并维护一个专门用于记录LeetCode题解的GitHub仓库了。这不仅能帮助你跟踪自己的学习进度，还能展示你的编程能力和解题思路。","link":"/2024/01/05/%E5%88%9B%E5%BB%BAgithub%E4%BB%93%E5%BA%93/"},{"title":"leetcode-hot100","text":"","link":"/2024/12/25/leetcode-hot100/"},{"title":"leetcode-单调栈","text":"单调栈 1、每日温度 739https://leetcode.cn/problems/daily-temperatures/description/ 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 示例 1: 12输入: temperatures = [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0] 示例 2: 12输入: temperatures = [30,40,50,60]输出: [1,1,1,0] 示例 3: 12输入: temperatures = [30,60,90]输出: [1,1,0] 提示： 1 &lt;= temperatures.length &lt;= 105` 30 &lt;= temperatures[i] &lt;= 100 123456789101112131415161718192021222324import java.util.ArrayDeque;class Solution { public int[] dailyTemperatures(int[] temperatures) { int len = temperatures.length; int[] result = new int[len]; // 单调栈 ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(0); for (int i = 1; i &lt; len; i++) { if (temperatures[i] &lt;= temperatures[stack.peek()]){ stack.push(i); } else { while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) { result[stack.peek()] = i - stack.peek(); stack.pop(); } stack.push(i); } } return result; }} 2、下一个更大元素I 496https://leetcode.cn/problems/next-greater-element-i/description/ nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。 示例 1： 123456输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2： 12345输入：nums1 = [2,4], nums2 = [1,2,3,4].输出：[3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示： 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 104 nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？ 12345678910111213141516171819202122232425262728293031import java.util.ArrayDeque;import java.util.HashMap;class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; HashMap&lt;Integer,Integer&gt; hashmap = new HashMap&lt;&gt;(); //单调栈 ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(0); for (int i = 1; i &lt; len2; i++) { if (nums2[i] &lt;= nums2[stack.peek()]) { stack.push(i); }else { while(!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]){ hashmap.put(nums2[stack.peek()],nums2[i]); stack.pop(); } stack.push(i); } } int[] result = new int[len1]; for (int i = 0; i &lt; len1; i++) { result[i] = hashmap.getOrDefault(nums1[i], -1); } return result; }} 3、下一个更大元素II 503给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 示例 1: 12345输入: nums = [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 示例 2: 12输入: nums = [1,2,3,4,3]输出: [2,3,4,-1,4] 提示: 1 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 12345678910111213141516171819202122import java.util.ArrayDeque;import java.util.Arrays;class Solution { public int[] nextGreaterElements(int[] nums) { // 模拟对数组跑两遍，从而达到类似循环数组的效果 // 单调栈，也可以进行优化 int len = nums.length; ArrayDeque &lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(0); int[] result = new int[len]; Arrays.fill(result, -1); for (int i = 1; i &lt; len * 2; i++) { while(!stack.isEmpty() &amp;&amp; nums[i % len] &gt; nums[stack.peek()]) { result[stack.peek()] = nums[i%len]; stack.pop(); } stack.push(i%len); } return result; }} 4、接雨水 42给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 https://leetcode.cn/problems/trapping-rain-water/description/ 示例 1： 123输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 12输入：height = [4,2,0,3,2,5]输出：9 提示： n == height.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= height[i] &lt;= 105 1234567891011121314151617181920212223242526import java.util.ArrayDeque;class Solution { public int trap(int[] height) { int len = height.length; int result = 0; ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(0); /* * 单调递增栈，所以越往里越大 */ for (int i = 1; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) { int curHeight = height[stack.peek()]; stack.pop(); if(!stack.isEmpty()) { int secondHeight = height[stack.peek()]; int resultHeight = Math.min(height[i],secondHeight) - curHeight; result += resultHeight * (i-stack.peek()-1); } } stack.push(i); } return result; }} 5、 柱状图中最大的矩形 84https://leetcode.cn/problems/largest-rectangle-in-histogram/description/ 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 1: 123输入：heights = [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10 示例 2： 12输入： heights = [2,4]输出： 4 提示： 1 &lt;= heights.length &lt;=105 0 &lt;= heights[i] &lt;= 104 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayDeque;class Solution { public int largestRectangleArea(int[] heights) { /* * 单调递减栈，从顶到底部依次递减，当前元素比栈顶小，表示当前元素是栈顶元素右边的第一个比栈顶元素小的值 * 然后栈中的第二个元素就是表示的是左边第一个比栈顶元素小的值 * 进而就可以拓展 高为栈顶元素的值，底为右边元素的序号-左边元素的序号-1 * 因为要找到比栈顶元素小的值，同时，栈底也要有元素作为左边元素的序号以供被减 * 例子是 2 4 6 8 进入栈后是 8 6 4 2 没有比栈顶元素小的值，不能进行计算，所以需要在高度数组的末尾加 0 * 从而 8 * （4-2-1）= 8 6*（4-1-1）= 12 从而可以往左右拓展 * 例子 8 6 4 2 进入栈后 8 然后 6比8 小，右边的元素找到了，但是左边的元素没有，无法进行计算，所以需要在高度数组的起始位置加0 * */ // 数组扩容 int[] newheights = new int[heights.length + 2]; System.arraycopy(heights, 0, newheights, 1, heights.length); // 单调递减栈 int len = newheights.length; ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int result = 0; stack.push(0); for (int i = 1; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; newheights[i] &lt; newheights[stack.peek()]) { // 当前元素，需要往左右扩展的值 // newheight[i] 表示的是右边比当前元素小的值，后续只需要下标 int height = newheights[stack.peek()]; stack.pop(); if (!stack.isEmpty()) { // 左边的下标 int left = stack.peek(); result = Math.max(height*(i-left-1),result); } } stack.push(i); } return result; }}","link":"/2024/12/25/leetcode-%E5%8D%95%E8%B0%83%E6%A0%88/"},{"title":"leetcode-动态规划","text":"动态规划 1、斐波那契数 509https://leetcode.cn/problems/fibonacci-number/description/ 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 示例 1： 123输入：n = 2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：n = 3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：n = 4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 123456789101112131415class Solution { public int fib(int n) { if (n &lt; 2) return n; int[] dp = new int[2]; dp[0] = 0; dp[1] = 1; int sum = 0; for (int i = 2; i &lt;= n; i++) { sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return sum; }} 2、爬楼梯 70https://leetcode.cn/problems/climbing-stairs/description/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 12345输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 提示： 1 &lt;= n &lt;= 45 1234567891011121314class Solution { public int climbStairs(int n) { if (n &lt; 2) return n; int low = 1; int high = 1; int sum = 0; for (int i = 2; i &lt;= n; i++) { sum = low + high; low = high; high = sum; } return sum; }} 3、使用最小花费爬楼梯https://leetcode.cn/problems/min-cost-climbing-stairs/ 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 示例 1： 12345输入：cost = [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。 示例 2： 12345678910输入：cost = [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。 提示： 2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999 12345678910111213141516class Solution { public int minCostClimbingStairs(int[] cost) { if (cost.length &lt; 2) { return 0; } int dp0 = 0; int dp1 = 0; int sum = 0; for (int i = 2; i &lt;= cost.length; i++) { sum = Math.min(dp0+cost[i-2], dp1+cost[i-1]); dp0 = dp1; dp1 = sum; } return sum; }} 4、不同路径https://leetcode.cn/problems/unique-paths/description/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 12输入：m = 3, n = 7输出：28 示例 2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 12输入：m = 7, n = 3输出：28 示例 4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 109 1234567891011121314151617class Solution { public int uniquePaths(int m, int n) { int [][]dp = new int[m][n]; for (int i = 0; i &lt; m; i++) { dp[i][0] = 1; }; for (int j = 0; j &lt; n; j++) { dp[0][j] = 1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; i &lt; n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 5、不同路径IIhttps://leetcode.cn/problems/unique-paths-ii/ 给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。 网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。 返回机器人能够到达右下角的不同路径数量。 测试用例保证答案小于等于 2 * 109。 示例 1： 123456输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 12输入：obstacleGrid = [[0,1],[0,0]]输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 &lt;= m, n &lt;= 100 obstacleGrid[i][j] 为 0 或 1 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int [][]dp = new int[m][n]; int label = 1; int label2 = 1; for (int i = 0; i &lt; m; i++) { if (obstacleGrid[i][0] == 1) { label = 0; } dp[i][0] = label; } for (int j = 0; j &lt; n; j++) { if (obstacleGrid[0][j] == 1) { label2 = 0; } dp[0][j] = label2; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j-1] == 0 &amp;&amp; obstacleGrid[i-1][j] == 0) { dp[i][j] = dp[i][j-1] + dp[i-1][j]; }else if (obstacleGrid[i][j-1] == 1 &amp;&amp; obstacleGrid[i-1][j] == 1) { dp[i][j] = 0; }else if (obstacleGrid[i][j-1] == 1) { dp[i][j] = dp[i-1][j]; }else if (obstacleGrid[i-1][j] == 1) { dp[i][j] = dp[i][j-1]; } } } if (obstacleGrid[m-1][n-1] == 1) { return 0; } else { return dp[m-1][n-1]; } }} 6、整数拆分https://leetcode.cn/problems/integer-break/description/ 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 示例 1: 123输入: n = 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 123输入: n = 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示: 2 &lt;= n &lt;= 58 123456789101112131415class Solution { public int integerBreak(int n) { // dpn 表示n这个整数拆分后的最大乘积值 int[]dp = new int[n+1]; dp[0] = 0; dp[0] = 0; dp[2] = 1; for (int i = 3; i &lt;= n; i++){ for (int j = 1; j &lt; i; j++) { dp[i] = Math.max(dp[i],Math.max(j*(i-j), j*dp[i-j])); } } return dp[n]; }} 7、不同的二叉搜索树https://leetcode.cn/problems/unique-binary-search-trees/description/ 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 12输入：n = 3输出：5 示例 2： 12输入：n = 1输出：1 提示： 1 &lt;= n &lt;= 19 12345678910111213class Solution { public int numTrees(int n) { int dp [] = new int[n+1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) { for (int j = 0 ; j &lt; i; j++) { dp[i] += dp[j]*dp[i-j-1]; } } return dp[n]; }} 8、01背包问题题目描述小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。 输入描述第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。 第二行包含 M 个正整数，代表每种研究材料的所占空间。 第三行包含 M 个正整数，代表每种研究材料的价值。 输出描述输出一个整数，代表小明能够携带的研究材料的最大价值。 输入示例1236 12 2 3 1 5 22 3 1 5 4 3 输出示例15 提示信息小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 数据范围：1 &lt;= N &lt;= 50001 &lt;= M &lt;= 5000研究材料占用空间和价值都小于等于 1000 123456789101112131415161718192021222324252627import java.util.*;public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int M = scanner.nextInt(); int N = scanner.nextInt(); int[] weight = new int[M]; int[] value = new int[M]; for (int i = 0; i &lt; M; i++) { weight[i] = scanner.nextInt(); } for (int i = 0; i &lt; M; i++) { value[i] = scanner.nextInt(); } int dp[] = new int[N + 1]; for (int i = 0; i &lt; M ; i++) { for (int j = N; j &gt;= weight[i];j--) { dp[j] = Math.max(dp[j],dp[j - weight[i]]+value[i]); } } System.out.println(dp[N]); } } 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int M = scanner.nextInt(); // 物品数量 int N = scanner.nextInt(); // 背包容量 int[] weight = new int[M]; // 物品重量 int[] value = new int[M]; // 物品价值 for (int i = 0; i &lt; M; i++) { weight[i] = scanner.nextInt(); } for (int i = 0; i &lt; M; i++) { value[i] = scanner.nextInt(); } // 初始化二维DP数组，行数是M+1，列数是N+1 int[][] dp = new int[M + 1][N + 1]; // 动态规划计算最大价值 for (int i = 1; i &lt;= M; i++) { for (int j = 0; j &lt;= N; j++) { if (j &gt;= weight[i - 1]) { // 如果当前背包容量大于等于物品i的重量 // 选择放入当前物品与不放入当前物品的最大价值 dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } else { // 当前背包容量不足以放入物品i，保持不变 dp[i][j] = dp[i - 1][j]; } } } // 输出最大价值 System.out.println(dp[M][N]); }} 9、分割等和子集https://leetcode.cn/problems/partition-equal-subset-sum/description/ 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 123输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 1234567891011121314151617181920212223import java.util.Arrays;import java.util.stream.IntStream;class Solution { public boolean canPartition(int[] nums) { // 01背包问题，背包容量为数组和的一半，物体的重量和价值为数值 // int sum = Arrays.stream(nums).sum(); int sum = IntStream.of(nums).sum(); int half = sum / 2; if (sum % 2 == 1) { return false; } int []dp = new int[half+1]; for (int i = 0; i &lt; nums.length; i++) { for (int j = half; j &gt;= nums[i]; j--) { dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]); } } if (dp[half] == half) { return true; } else return false; }} 10、最后一块石头的重量II有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例 1： 1234567输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2： 12输入：stones = [31,26,33,21,40]输出：5 提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100 1234567891011121314151617import java.util.stream.IntStream;class Solution { public int lastStoneWeightII(int[] stones) { // 转化为01背包问题，看容量为总和的一半的背包最多可以装多上价值的石头 int sum = IntStream.of(stones).sum(); int target = sum / 2; int [] dp = new int[target + 1]; for (int i = 0; i &lt; stones.length; i++) { for (int j = target; j &gt;= stones[i]; j--) { dp[j] = Math.max(dp[j],dp[j-stones[i]] + stones[i]); } } return sum - 2 * dp[target]; }} 11、目标和https://leetcode.cn/problems/target-sum/ 给你一个非负整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 示例 2： 12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000 1234567891011121314151617181920212223242526272829import java.util.stream.IntStream;class Solution { public int findTargetSumWays(int[] nums, int target) { /* * left 表示正数，right 表示负数，left + right = target, left - right = sum * left = target + sum /2，如果不是整数说明不存在这样的构造方法 * dp[j] 表示装满j容量的背包，总共有多少种不同的方法 * 先考虑二维数组的情况，dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]; * 表示为不用最后一个数字填满容量，和使用最后一个数字填满容量 这两种情况 * dp[j] = dp[j] + dp [j-nums[i]]; */ int sum = IntStream.of(nums).sum(); int left = target + sum; if (left % 2 == 1 || left &lt; 0) { return 0; } else { left = left / 2; } int [] dp = new int [left + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; i++) { for (int j = left; j &gt;= nums[i]; j--) { dp[j] = dp[j] + dp[j - nums[i]]; } } return dp[left]; }} 12、一和零https://leetcode.cn/problems/ones-and-zeroes/description/ 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 1234输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 {&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;} ，因此答案是 4 。其他满足题意但较小的子集包括 {&quot;0001&quot;,&quot;1&quot;} 和 {&quot;10&quot;,&quot;1&quot;,&quot;0&quot;} 。{&quot;111001&quot;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 123输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 {&quot;0&quot;, &quot;1&quot;} ，所以答案是 2 。 提示： 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] 仅由 '0' 和 '1' 组成 1 &lt;= m, n &lt;= 100 12345678910111213141516171819202122232425class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][][] dp = new int[strs.length+1][m+1][n+1]; for (int i = 1; i &lt;= strs.length; i++) { int zeros = 0, ones = 0; for (char ch : strs[i-1].toCharArray()) { if (ch == '1') { ones++; } else { zeros++; } } for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt;= n; k++) { if (j &gt;= zeros &amp;&amp; k &gt;= ones) { dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-zeros][k-ones] + 1); }else { dp[i][j][k] = dp[i-1][j][k]; } } } } return dp[strs.length][m][n]; }} 123456789101112131415161718192021222324class Solution { public int findMaxForm(String[] strs, int m, int n) { int [][] dp = new int [m+1][n+1]; int zeros = 0 , ones = 0; for (String str : strs) { zeros = 0; ones = 0; for(char ch : str.toCharArray()) { if (ch == '1') { ones ++; } else { zeros++; } } for (int i = m; i &gt;= zeros; i--) { for (int j = n; j &gt;= ones; j--) { dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones]+1); } } } return dp[m][n]; }} 13、01背包和完全背包0/1 背包问题和完全背包问题虽然都是经典的背包问题，但它们在物品选择上有很大的区别。以下是两者的区别和解法差异： 物品选择限制： 0/1 背包问题 ：每个物品只能选择一次。对于每种物品，我们只能选择放入背包或不放入背包。 例如：如果有 3 种物品，背包的容量为 5，你只能选择其中某些物品，且每种物品只能选择一次。 完全背包问题 ：每个物品可以选择无数次。对于每种物品，我们可以选择放入背包任意多次，只要背包容量允许。 例如：如果有 3 种物品，背包的容量为 5，你可以选择同一种物品放入背包多次，直到背包装满。 动态规划的转移方程差异： 0/1 背包问题的状态转移方程： 对于每个物品 i 和每个背包容量 j，如果我们决定 **不选物品 i**，那么 dp[i][j] = dp[i-1][j]（即不选择物品 i 时，价值就是选择前 i-1 种物品时的最大值）。 如果我们决定 **选物品 i**，那么 dp[i][j] = dp[i-1][j-w[i]] + v[i]（即选择物品 i 时，价值就是选择前 i-1 种物品时，剩余容量的最大值 + 物品 i 的价值）。 完全背包问题的状态转移方程： 对于每个物品 i 和每个背包容量 j，如果我们决定 **不选物品 i**，则 dp[i][j] = dp[i-1][j]（即不选择物品 i 时，价值就是选择前 i-1 种物品时的最大值）。 如果我们决定 **选物品 i**，那么 dp[i][j] = dp[i][j - w[i]] + v[i]（注意，物品可以重复选择，因此这里 i 仍然不变，而是对背包容量逐渐递减）。这意味着如果 j 足够大，我们可以重复选择物品 i，直到容量用尽。 动态规划数组的使用差异： 0/1 背包问题：通常用二维数组 dp[i][j] 表示前 i 个物品，背包容量为 j 时的最大价值。每次物品只能选择一次，所以在更新 dp[i][j] 时，我们只能参考 dp[i-1][j] 和 dp[i-1][j-w[i]] + v[i]。 完全背包问题：可以使用一维数组 dp[j]，表示背包容量为 j 时的最大价值。由于每个物品可以选择多次，因此我们需要从当前容量 j 逐步递减更新。在每次选择物品时，当前物品可能被选多次，所以状态转移时可能会使用 dp[j - w[i]] + v[i] 来更新当前容量。 示例解析： 0/1 背包问题： 输入： 12345复制代码4 51 22 43 44 5 物品有 4 种，背包容量为 5。 每种物品只能选择一次。 物品的重量和价值分别为： 1234scss复制代码(1, 2)(2, 4)(3, 4)(4, 5) 解法： 我们会使用动态规划数组 dp[i][j]，表示在选择前 i 种物品时，背包容量为 j 时的最大价值。 对于每个物品，如果背包容量足够，我们可以选择放入背包，或者跳过该物品。 状态转移方程： 对于每种物品，我们有两种选择：不选择该物品，或者选择该物品（如果容量足够）。 完全背包问题： 输入： 12345复制代码4 51 22 43 44 5 物品有 4 种，背包容量为 5。 每种物品可以选择多次。 物品的重量和价值分别为： 1234scss复制代码(1, 2)(2, 4)(3, 4)(4, 5) 解法： 我们使用动态规划数组 dp[j]，表示背包容量为 j 时的最大价值。 对于每个物品，我们从容量 j 递减更新 dp[j]。对于容量 j，我们可以选择放入该物品，并且该物品可能被放入多次。 状态转移方程： 对于每种物品 i，我们可以选择放入背包，直到背包无法再装下该物品。 代码实现差异： 0/1 背包问题： 123456java复制代码for (int i = 1; i &lt;= n; i++) { for (int j = v; j &gt;= w[i-1]; j--) { dp[j] = Math.max(dp[j], dp[j - w[i-1]] + v[i-1]); }} 在 0/1 背包问题中，内层循环 j 从背包容量 v 到 w[i-1] 递减，这样可以保证每个物品只能选一次。 完全背包问题： 123456java复制代码for (int i = 1; i &lt;= n; i++) { for (int j = w[i-1]; j &lt;= v; j++) { dp[j] = Math.max(dp[j], dp[j - w[i-1]] + v[i-1]); }} 在完全背包问题中，内层循环 j 从物品的重量 w[i-1] 开始递增，这样允许物品选择多次。 总结： 0/1 背包问题：每种物品只能选择一次，因此在动态规划更新时，必须保证每个物品最多使用一次，通常通过从背包容量的高到低更新 dp 数组来实现。 完全背包问题：每种物品可以选择多次，因此在动态规划更新时，不需要限制每个物品的使用次数，通常通过从背包容量的低到高更新 dp 数组来实现。 \\52. 携带研究材料（第七期模拟笔试） 题目描述小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。 小明的行李箱所能承担的总重量是有限的，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。 输入描述第一行包含两个整数，n，v，分别表示研究材料的种类和行李所能承担的总重量 接下来包含 n 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值 输出描述输出一个整数，表示最大价值。 输入示例123454 51 22 43 44 5 输出示例110 提示信息第一种材料选择五次，可以达到最大值。 数据范围： 1 &lt;= n &lt;= 10000;1 &lt;= v &lt;= 10000;1 &lt;= wi, vi &lt;= 10^9. 12345678910111213141516171819202122232425import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int v = sc.nextInt(); int [][] dp = new int[n+1][v+1]; int [] w = new int[n]; int [] val = new int [n]; for (int i = 0 ; i &lt; n; i++) { w[i] = sc.nextInt(); val[i] = sc.nextInt(); } for (int i = 1; i &lt;= n; i++){ for (int j = 0; j &lt;= v; j++) { dp[i][j] = dp[i-1][j]; if (j &gt;= w[i-1]) { dp[i][j] = Math.max(dp[i-1][j],dp[i][j-w[i-1]]+val[i-1]); } } } System.out.println(dp[n][v]); }} 123456789101112131415161718192021222324252627282930import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 输入n和v int n = sc.nextInt(); int v = sc.nextInt(); // dp数组，表示背包容量j时能获得的最大价值 int[] dp = new int[v + 1]; // 输入每种物品的重量和价值 for (int i = 0; i &lt; n; i++) { int wi = sc.nextInt(); int vi = sc.nextInt(); // 完全背包问题的核心逻辑 // 注意这里是从当前容量v到wi倒序遍历 for (int j = wi; j &lt;= v; j++) { dp[j] = Math.max(dp[j], dp[j - wi] + vi); } } // 输出最大价值 System.out.println(dp[v]); }} 14、零钱兑换IIhttps://leetcode.cn/problems/coin-change-ii/description/ 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 1234567输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 示例 2： 123输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3： 12输入：amount = 10, coins = [10] 输出：1 提示： 1 &lt;= coins.length &lt;= 300 1 &lt;= coins[i] &lt;= 5000 coins 中的所有值 互不相同 0 &lt;= amount &lt;= 5000 123456789101112131415class Solution { public int change(int amount, int[] coins) { // dp[j]表示凑成amout金额的方案的数量 // 用前i-1种钱币凑成总额，不使用最后一种钱币，或者使用最后一种钱币，即前i-1种钱币凑成amout-coins[i]总额的钱币 // 方案数表示为 dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] int [] dp = new int[amount + 1]; dp[0] = 1; for (int i = 0; i &lt; coins.length; i++) { for (int j = coins[i]; j &lt;= amount; j++) { dp[j] = dp[j] + dp[j-coins[i]]; } } return dp[amount]; }} 15、组合总和IVhttps://leetcode.cn/problems/combination-sum-iv/description/ 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 123456789101112输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。 示例 2： 12输入：nums = [9], target = 3输出：0 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 1000 nums 中的所有元素 互不相同 1 &lt;= target &lt;= 1000 进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？ 1234567891011121314class Solution { public int combinationSum4(int[] nums, int target) { int []dp = new int[target+1]; dp[0] = 1; for (int j = 1; j &lt;= target; j++) { for (int i = 0; i &lt; nums.length; i++) { if (j &gt;= nums[i]) { dp[j] = dp[j] + dp[j-nums[i]]; } } } return dp[target]; }} 如果给定的数组中含有负数，则会导致出现无限长度的排列。 例如，假设数组 nums 中含有正整数 a 和负整数 −b（其中 a&gt;0,b&gt;0,−b&lt;0），则有 a×b+(−b)×a=0，对于任意一个元素之和等于 target 的排列，在该排列的后面添加 b 个 a 和 a 个 −b 之后，得到的新排列的元素之和仍然等于 target，而且还可以在新排列的后面继续 b 个 a 和 a 个 −b。因此只要存在元素之和等于 target 的排列，就能构造出无限长度的排列。 如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数。 16、爬楼梯（进阶版）原本是普通动态规划，进阶后为完全背包问题 https://kamacoder.com/problempage.php?pid=1067 题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 输入描述输入共一行，包含两个正整数，分别表示n, m 输出描述输出一个整数，表示爬到楼顶的方法数。 输入示例13 2 输出示例13 提示信息数据范围：1 &lt;= m &lt; n &lt;= 32; 当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。 此时你有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶段 1 阶 + 2 阶 2 阶 + 1 阶 12345678910111213141516171819import java.util.*;public class Main { public static void main (String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int []dp = new int [n+1]; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1;j &lt;= m; j++) { if (i &gt;= j) { dp[i] = dp[i] + dp[i-j]; } } } System.out.println(dp[n]); }} 17、零钱兑换https://leetcode.cn/problems/coin-change/description/ 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 示例 2： 12输入：coins = [2], amount = 3输出：-1 示例 3： 12输入：coins = [1], amount = 0输出：0 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 231 - 1 0 &lt;= amount &lt;= 104 123456789101112131415161718192021import java.util.Arrays;class Solution { public int coinChange(int[] coins, int amount) { // dp[j] 表示凑成总金额为j的时候，所需要花费的最少硬币个数 int [] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; coins.length; i++) { for (int j = coins[i]; j &lt;= amount; j++) { if (dp[j - coins[i]]!= Integer.MAX_VALUE) { dp[j] = Math.min(dp[j],dp[j-coins[i]]+1); } } } if(dp[amount] == Integer.MAX_VALUE) { return -1; }else { return dp[amount]; } }} 18、完全平方数https://leetcode.cn/problems/perfect-squares/description/ 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 示例 2： 12输入：coins = [2], amount = 3输出：-1 示例 3： 12输入：coins = [1], amount = 0输出：0 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 231 - 1 0 &lt;= amount &lt;= 104 12345678910111213141516import java.util.Arrays;class Solution { public int numSquares(int n) { // dp[j] 表示和为j的完全平方数的最少数量 int[] dp = new int[n + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 1; i*i &lt;= n; i++) { for (int j = i*i; j &lt;= n; j++) { dp[j] = Math.min(dp[j], dp[j-i*i]+1); } } return dp[n]; }} 19、单词拆分https://leetcode.cn/problems/word-break/description/ 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 提示： 1 &lt;= s.length &lt;= 300 1 &lt;= wordDict.length &lt;= 1000 1 &lt;= wordDict[i].length &lt;= 20 s 和 wordDict[i] 仅由小写英文字母组成 wordDict 中的所有字符串 互不相同 1234567891011121314151617181920import java.util.HashSet;import java.util.*;class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { Set&lt;String&gt; wordSet = new HashSet&lt;String&gt;(wordDict); // dp数组表示长度为j的字符串，能不能被wordSet表示出来 boolean[] dp = new boolean[s.length()+1]; dp[0] = true; for (int i = 1; i &lt;= s.length(); i++) { for (int j = 0; j &lt; i; j++) { String word = s.substring(j, i); if (dp[j] &amp;&amp; wordSet.contains(word)) { dp[i] = true; } } } return dp[s.length()]; }} 20、打家劫舍https://leetcode.cn/problems/house-robber/description/ 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 1234567891011121314151617class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } if (nums.length == 2) { return Math.max(nums[0], nums[1]); } int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for (int i = 2 ; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]); } return dp[nums.length-1]; }} 21、打家劫舍II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 1234输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 12输入：nums = [1,2,3]输出：3 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 1000 123456789101112131415161718class Solution { public int rob(int[] nums) { int len = nums.length-1; if (len == 0) { return nums[0]; } return Math.max(robBase(nums, 1, len),robBase(nums, 0, len-1)); } public int robBase (int[] nums, int start, int end) { int x = 0, y = 0, z = 0; for (int i = start; i &lt;= end; i++) { y = z; z = Math.max(x+nums[i], y); x = y; } return z; }} 22 打家劫舍III小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 示例 1: 123输入: root = [3,2,3,null,3,null,1]输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2: 123输入: root = [3,4,5,1,3,null,1]输出: 9解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9 提示： 树的节点数在 [1, 104] 范围内 0 &lt;= Node.val &lt;= 104 123456789101112131415161718192021222324252627282930313233343536373839class TreeNode { int val; TreeNode left; TreeNode right; // 默认构造函数 TreeNode() {} // 带值的构造函数 TreeNode(int val) { this.val = val; } // 带左右子节点的构造函数 TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }}class Solution { public int rob(TreeNode root) { // 定义每个节点有两个状态dp[0]表示该节点不偷的情况下能够获得的最大金额，dp[1]表示该节点偷的情况下能够获得的最大金额 int[] result = backTravel(root); return Math.max (result[0],result[1]); } public int[] backTravel (TreeNode root) { if (root == null) { return new int[]{0,0}; } int[] leftResult = backTravel(root.left); int[] rightResult = backTravel(root.right); int[] result = new int[2]; result[0] = Math.max(leftResult[0],leftResult[1]) + Math.max(rightResult[0],rightResult[1]); result[1] = leftResult[0] + rightResult[0] + root.val; return result; }} 23、买卖股票的最佳时机https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/ 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 123456789101112131415161718class Solution { public int maxProfit(int[] prices) { // dp[i][0]表示第i天不持有股票的最大金额，dp[i][1]表示第i天持有股票的最大金额 // dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]) // dp[i][1] = Math.max(dp[i-1][1], - prices[i]) // dp[0][0] = 0; // dp[0][1] = -prices[i]; int len = prices.length; int[][]dp = new int[len][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[len-1][0]; }} 24、买卖股票的最佳时机IIhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/submissions/ 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。最大总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。最大总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 1234567891011121314class Solution { public int maxProfit(int[] prices) { int result = 0; if (prices.length == 1) { return 0; } for (int i = 1 ;i &lt; prices.length ;i++ ) { if (prices[i] &gt; prices[i-1]) { result += prices[i] - prices[i-1]; } } return result; }} 12345678910111213141516class Solution { public int maxProfit(int[] prices) { int len = prices.length; int[][] dp = new int[len][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); // 可以买卖多次，前一天不持有股票减去当天买入股票的价格 dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]); } return dp[len-1][0]; }} 25、买卖股票的最佳时机IIIhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/ 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 12345输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 123输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 12输入：prices = [1]输出：0 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 1234567891011121314151617181920212223242526class Solution { public int maxProfit(int[] prices) { /* * 定义五个状态，dp[i][0],表示不操作，此时持有的最大金额 * dp[i][1]表示第一次股票持有的状态，这个状态可以延续，此时持有的最大金额 * dp[i][2]表示第一次股票卖出的状态，这个状态可以延续，此时持有的最大金额 * dp[i][3]表示第二次股票持有的状态，这个状态可以延续，此时持有的最大金额 * dp[i][4]表示第二次股票卖出的状态，这个状态可以延续，此时持有的最大金额 */ int len = prices.length; int[][]dp = new int[len][5]; dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = -prices[0]; dp[0][4] = 0; for (int i = 1; i &lt; len; i++) { dp[i][0] = 0; dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]); dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1]+prices[i]); dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2]-prices[i]); dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3]+prices[i]); } return Math.max(dp[len-1][2],dp[len-1][4]); }} 26、买卖股票的最佳时机IVhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/ 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 123输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 1234输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 1 &lt;= k &lt;= 100 1 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 1234567891011121314151617181920class Solution { public int maxProfit(int k, int[] prices) { int len = prices.length; int [][]dp = new int[len][2*k+1]; //初始化 for(int j = 1; j &lt;2*k; j+=2) { if (j % 2 == 1) { dp[0][j] = -prices[0]; } } //状态转移 for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; 2*k; j+=2){ dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j]-prices[i]); dp[i][j+2] = Math.max(dp[i-1][j+2], dp[i-1][j+1]+prices[i]); } } return dp[len-1][2*k]; }} 27、最佳买卖股票时机含冷冻期https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/ 给定一个整数数组prices，其中第 prices[i] 表示第 *i* 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 123输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2: 12输入: prices = [1]输出: 0 提示： 1 &lt;= prices.length &lt;= 5000 0 &lt;= prices[i] &lt;= 1000 123456789101112131415161718192021222324252627class Solution { public int maxProfit(int[] prices) { int len = prices.length; // 1.确定dp数组的含义 int[][] dp = new int[len][4]; /* * 这里定义四个状态,均是该状态下持有的最大金额 * dp[i][0] 保持持有股票的状态 * dp[i][1] 保持卖出股票的状态 * dp[i][2] 卖出股票 当天 * dp[i][3] 冷冻期 当天的后一天,不能再买 */ // 2.初始化dp数组 dp[0][0] = -prices[0]; dp[0][1] = 0; dp[0][2] = 0; dp[0][3] = 0; // 3.确定状态转移方程 for (int i = 1; i &lt; len ; i++) { dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]); dp[i][1] = Math.max(dp[i-1][1],dp[i-1][2]); dp[i][2] = dp[i-1][0] + prices[i]; dp[i][3] = dp[i][2]; } return Math.max(dp[len-1][2],dp[len-1][1]); }} 28、买卖股票的最佳时机含手续费https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/ 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 12345678输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 12输入：prices = [1,3,7,5,10,3], fee = 3输出：6 提示： 1 &lt;= prices.length &lt;= 5 * 104 1 &lt;= prices[i] &lt; 5 * 104 0 &lt;= fee &lt; 5 * 104 1234567891011121314151617181920class Solution { public int maxProfit(int[] prices, int fee) { int len = prices.length; //1.定义dp数组 /* * dp[i][0] 持有股票的状态 * dp[i][1] 卖出股票的状态 */ int[][]dp = new int[len][2]; //2.初始化dp数组 dp[0][0] = -prices[0]; dp[0][1] = 0; //3.确定状态转移方程 for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]); dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i] - fee); } return dp[len-1][1]; }} 29、最长递增子序列 300https://leetcode.cn/problems/longest-increasing-subsequence/description/ 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列 示例 1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums = [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums = [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 进阶： 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 12345678910111213141516171819202122232425import java.util.Arrays;class Solution { public int lengthOfLIS(int[] nums) { int len = nums.length; //1.定义dp数组 /* * dp[i] 表示以nums[i]结尾的最长子序列的长度 */ int[] dp = new int[len]; //2. dp数组初始化 Arrays.fill(dp,1); //3. 状态转移方程 int result = 1; for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; i; j++) { if (nums[j] &lt; nums[i]) { dp[i] = Math.max(dp[i],dp[j]+1); } } result = Math.max(result, dp[i]); } return result; }} 30、最长连续递增序列 674https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/ 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 1234输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 123输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。 提示： 1 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 12345678910111213141516import java.util.Arrays;class Solution { public int findLengthOfLCIS(int[] nums) { int len = nums.length; int[]dp = new int[len]; Arrays.fill(dp,1); int result = 1; for (int i = 1; i &lt; len; i++) { if (nums[i] &gt; nums[i-1]) { dp[i] = dp[i-1] + 1; result = Math.max (dp[i],result); } } return result; }} 31、最长重复子数组 718https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/ 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 示例 1： 123输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3,2,1] 。 示例 2： 12输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]输出：5 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 100 1234567891011121314151617181920212223242526272829class Solution { public int findLength(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; //1.定义dp数组 /* * 为什么这么定义？dp[i][j]表示以nums[i-1]和nums[j-1]结尾的最长公众子数组的长度， * 这样在初始化的时候，第一行和第一列就是没有意义的，直接赋为0， * 否则的话，如果表示num[i]和nums[j]结尾的最长公共子数组的长度的话，第一行和第一列要分别进行判断，是否相等 * 相等为1 ，不等为0 */ int[][]dp = new int[len1+1][len2+1]; //2.dp数组初始化 //3.状态转移方程 int result = 0; for(int i = 1; i &lt;= len1; i++) { for(int j = 1; j &lt;= len2; j++) { if(nums1[i-1] == nums2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; result = Math.max(result,dp[i][j]); } } } return result; }} 32、最长公共子序列 1143https://leetcode.cn/problems/longest-common-subsequence/description/ 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。 示例 2： 123输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。 示例 3： 123输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0 。 提示： 1 &lt;= text1.length, text2.length &lt;= 1000 text1 和 text2 仅由小写英文字符组成。 1234567891011121314151617181920class Solution { public int longestCommonSubsequence(String text1, String text2) { int len1 = text1.length(); int len2 = text2.length(); // dp[i][j] 表示以i-1和j-1结尾的字符串具有的最长公共子序列 int[][]dp = new int[len1+1][len2+1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (text1.charAt(i-1) == text2.charAt(j-1)) { dp[i][j] = dp[i-1][j-1]+1; System.out.println(dp[i][j]); }else { dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]); } } } return dp[len1][len2]; }} 33、不相交的线 1035https://leetcode.cn/problems/uncrossed-lines/description/在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例 1： 1234输入：nums1 = [1,4,2], nums2 = [1,2,4]输出：2解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2： 12输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]输出：3 示例 3： 12输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]输出：2 提示： 1 &lt;= nums1.length, nums2.length &lt;= 500 1 &lt;= nums1[i], nums2[j] &lt;= 2000 12345678910111213141516171819class Solution { public int maxUncrossedLines(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int[][] dp = new int[len1+1][len2+1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (nums1[i-1] == nums2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]); } } } return dp[len1][len2]; }} 34、最大子数组和 53https://leetcode.cn/problems/maximum-subarray/description/ 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 123456789101112131415161718// 贪心class Solution { public int maxSubArray(int[] nums) { int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count += nums[i]; if(count &gt; result) { result = count; } if (count &lt; 0) { count = 0; } } return result; }} 12345678910111213141516class Solution { public int maxSubArray(int[] nums) { int len = nums.length; int[] dp = new int[len]; dp[0] = nums[0]; /* * dp[i]表示以nums[i]结尾的最大子数组和 */ int result = dp[0]; for (int i = 1; i &lt; len; i++) { dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); result = Math.max(result, dp[i]); } return result; }} 35、判断子序列 392https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 致谢： 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 示例 1： 12输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;输出：true 示例 2： 12输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;输出：false 提示： 0 &lt;= s.length &lt;= 100 0 &lt;= t.length &lt;= 10^4 两个字符串都只由小写字符组成。 123456789101112131415161718192021222324class Solution { public boolean isSubsequence(String s, String t) { int len1 = s.length(); int len2 = t.length(); if (len1 &gt; len2) { return false; } int[][] dp = new int[len1+1][len2+1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (s.charAt(i-1) == t.charAt(j-1)) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]); } } } if (len1 == dp[len1][len2]) { return true; }else { return false; } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;public class SubsequenceChecker { // 使用二分查找和 positionMap 判断 s 是否是 t 的子序列 public static boolean isSubsequence(String s, String t) { // 1. 构建 positionMap，记录每个字符在 t 中的位置 Map&lt;Character, List&lt;Integer&gt;&gt; positionMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) { char c = t.charAt(i); positionMap.computeIfAbsent(c, k -&gt; new ArrayList&lt;&gt;()).add(i); } // 2. 使用一个指针来跟踪在 t 中的位置 int prevIndex = -1; // 初始为 -1，表示我们还没有找到任何字符 // 3. 遍历字符串 s for (char c : s.toCharArray()) { // 4. 如果 positionMap 中没有字符 c，直接返回 false if (!positionMap.containsKey(c)) { return false; } // 5. 获取 c 在 t 中的位置列表 List&lt;Integer&gt; positions = positionMap.get(c); // 6. 用二分查找找到第一个大于 prevIndex 的位置 int posIndex = binarySearch(positions, prevIndex); if (posIndex == positions.size()) { return false; // 如果没有找到合适的位置，返回 false } // 7. 更新 prevIndex prevIndex = positions.get(posIndex); } return true; // 如果遍历完 s 中所有字符都能找到对应位置，返回 true } // 二分查找：找第一个大于 prevIndex 的位置 private static int binarySearch(List&lt;Integer&gt; positions, int prevIndex) { int left = 0, right = positions.size(); while (left &lt; right) { int mid = (left + right) / 2; if (positions.get(mid) &gt; prevIndex) { right = mid; } else { left = mid + 1; } } return left; } public static void main(String[] args) { String t = &quot;ahbgdc&quot;; // 测试案例 String[] queries = {&quot;abc&quot;, &quot;axc&quot;, &quot;ab&quot;, &quot;ahc&quot;}; for (String s : queries) { boolean result = isSubsequence(s, t); System.out.println(&quot;Is \\&quot;&quot; + s + &quot;\\&quot; a subsequence of \\&quot;&quot; + t + &quot;\\&quot;? &quot; + result); } }} 36、不同的子序列 115https://leetcode.cn/problems/distinct-subsequences/description/ 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。 示例 1： 1234567输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;输出：3解释：如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。rabbbitrabbbitrabbbit 示例 2： 123456789输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;输出：5解释：如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 babgbagbabgbagbabgbagbabgbagbabgbag 提示： 1 &lt;= s.length, t.length &lt;= 1000 s 和 t 由英文字母组成 1234567891011121314151617181920212223242526class Solution { public int numDistinct(String s, String t) { int len1 = s.length(); int len2 = t.length(); int[][] dp = new int[len1+1][len2+1]; /* * dp[i][j]表示以j-1结尾的字符串 在i-1结尾的字符串中出现的个数 * 0 就表示空字符串，在任何子串中都能出现 */ for (int i = 1; i &lt;= len1; i++) { dp[i][0] = 1; } dp[0][0] = 1; for(int i = 1; i &lt;= len1; i++) { for (int j = 1; j&lt;= len2; j++) { if (s.charAt(i-1) == t.charAt(j-1)) { dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; }else { dp[i][j] = dp[i-1][j]; } } } return dp[len1][len2] % 1000000007; }} 37、两个字符串的删除操作 583https://leetcode.cn/problems/delete-operation-for-two-strings/description/ 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 示例 1： 123输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;输出: 2解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot; 示例 2: 12输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;输出：4 提示： 1 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 只包含小写英文字母 12345678910111213141516171819202122class Solution { public int minDistance(String word1, String word2) { // 找出两个串的最长公共子串的长度，然后用各自减去最长公共子串的长度 int len1 = word1.length(); int len2 = word2.length(); int[][]dp = new int[len1+1][len2+1]; for (int i = 1; i &lt;= len1; i++) { for (int j = 1 ; j &lt;= len2; j++) { if (word1.charAt(i-1) == word2.charAt(j-1)) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); } } } int length = dp[len1][len2]; return len1+len2-2*length; }} 38、编辑距离 72https://leetcode.cn/problems/edit-distance/description/ 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e') 示例 2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); /* * dp[i][j],表示将i-1这个字符结尾的字符串，转化为以j-1这个字符结尾的字符串需要的最小操作数 * */ int[][] dp = new int[len1+1][len2+1]; // 初始化 dp[0][0] = 0; // 删除该字符，word1有多少个删除多少个，才能让word1变为word2 for (int i = 1; i &lt;= len1; i++) { dp[i][0] = i; } // 增加对应的字符，word2有多少字符，word1就要增加多少个字符 for (int j = 1; j &lt;= len2; j++) { dp[0][j] = j; } // 状态转移 for (int i = 1; i &lt;= len1; i++) { for (int j = 1; j &lt;= len2; j++) { if (word1.charAt(i-1) == word2.charAt(j-1)) { dp[i][j] = dp[i-1][j-1]; }else { /* * 1.增 word1在和word2不相等的地方 (i,j)，增加一个字符从而使得二者相等，等价于 dp[i][j-1] + 1; * 2.删 word1在和word2不相等的地方 (i,j)，删除一个字符从而使得二者相等，等价于 dp[i-1][j] + 1; * 3.替换 word1在和word2不相等的地方 (i,j)，修改一个字符从而使得二者相等，等价于 dp[i-1][j-1] + 1; * 取三者操作的最小值 */ dp[i][j] = Math.min(Math.min(dp[i][j-1] + 1, dp[i-1][j] + 1), dp[i-1][j-1] + 1); } } } return dp[len1][len2]; }} 39、回文子串 647https://leetcode.cn/problems/palindromic-substrings/description/ 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 示例 1： 123输入：s = &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2： 123输入：s = &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由小写英文字母组成 123456789101112131415161718192021222324252627282930class Solution { public int countSubstrings(String s) { /* * dp数组的定义，dp[i][j]表示左闭右闭的范围内的字符串是回文子串 * 当s.charAt(i) == s.charAt(j)的时候，如果dp[i+1][j-1]也是回文子串，那么它就为回文子串 * 将其想象成平面一直线的范围 * 遍历的时候再考虑是二维数组，从左下角开始遍历 */ int len = s.length(); int result = 0; boolean[][] dp = new boolean[len][len]; for (int i = len-1; i &gt;= 0; i--) { for (int j = i; j &lt; len; j++) { if (s.charAt(i) == s.charAt(j)) { if (j - i &lt; 2) { dp[i][j] = true; result++; }else { if(dp[i+1][j-1]) { dp[i][j] = true; result++; } } } } } return result; }} 40、最长回文子序列 516https://leetcode.cn/problems/longest-palindromic-subsequence/description/ 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 提示： 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成 123456789101112131415161718192021222324252627class Solution { public int longestPalindromeSubseq(String s) { int len = s.length(); int[][] dp = new int[len][len]; /* * dp[i][j]表示的含义是，i~j范围内的最长回文子序列的个数， * 如果i和j表示的字符相同时，如果i和j的范围相差0，dp[i][j] = 1; * dp[i][j] = dp[i+1][j-1] + 2 * */ for (int i = 0 ; i &lt; len; i++) { dp[i][i] = 1; } for (int i = len - 1; i &gt;= 0; i--) { for (int j = i+1; j &lt; len; j++) { if (s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i+1][j-1] + 2; } else { dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]); } } } return dp[0][len-1]; }}","link":"/2024/11/17/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"leetcode 贪心算法","text":"贪心算法 1.分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。 示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2。 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 12345678910111213141516class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int result = 0; int i = 0, j = 0; while (i &lt; s.length &amp;&amp; j &lt; g.length) { if (s[i] &gt;= g[j]) { result++; j++; } i++; } return result; }} 2.摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 示例 1： 123输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2： 1234输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3： 12输入：nums = [1,2,3,4,5,6,7,8,9]输出：2 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 进阶：你能否用 O(n) 时间复杂度完成此题? 123456789101112131415class Solution { public int wiggleMaxLength(int[] nums) { int result = 1; int prediff = 0; int curdiff = 0; for (int i = 0; i &lt; nums.length - 1; i++) { curdiff = nums[i+1]-nums[i]; if ((curdiff &gt; 0 &amp;&amp; prediff &lt;= 0) || (curdiff &lt; 0 &amp;&amp; prediff &gt;= 0)) { result++; prediff = curdiff; } } return result; }} 3、最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 1234567891011121314151617class Solution { public int maxSubArray(int[] nums) { int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count += nums[i]; if(count &gt; result) { result = count; } if (count &lt; 0) { count = 0; } } return result; }} 4、最大子序和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 12345678910111213141516class Solution { public int maxSubArray(int[] nums) { int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; i++) { count += nums[i]; if(count &gt; result) { result = count; } if (count &lt; 0) { count = 0; } } return result; }} 5、买卖股票的最佳时机II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。最大总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。最大总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 1234567891011121314class Solution { public int maxProfit(int[] prices) { int result = 0; if (prices.length == 1) { return 0; } for (int i = 1 ;i &lt; prices.length ;i++ ) { if (prices[i] &gt; prices[i-1]) { result += prices[i] - prices[i-1]; } } return result; }} 6、跳跃游戏给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 123输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 105 123456789101112131415class Solution { public boolean canJump(int[] nums) { int cover = 0; if (nums.length == 1) { return true; } for (int i = 0; i &lt;= cover; i++) { cover = Math.max(i+nums[i],cover); if (cover &gt;= nums.length-1) { return true; } } return false; }} 7、跳跃游戏II给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处: 0 &lt;= j &lt;= nums[i] i + j &lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 示例 1: 1234输入: nums = [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 12输入: nums = [2,3,0,1,4]输出: 2 提示: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 1000 题目保证可以到达 nums[n-1] 1234567891011121314151617181920212223class Solution { public int jump(int[] nums) { if (nums.length == 1) { return 0; } int result = 0 ; int curcover = 0; int maxcover = 0; for (int i = 0; i &lt; nums.length; i++) { maxcover = Math.max(maxcover,i+nums[i]); if (maxcover &gt;= nums.length-1) { result++; break; } if (i == curcover) { curcover = maxcover; result++; } } return result; }} 8、K次取反后最大化的数组和给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例 1： 123输入：nums = [4,2,3], k = 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3] 。 示例 2： 123输入：nums = [3,-1,0,2], k = 3输出：6解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 示例 3： 123输入：nums = [2,-3,-1,5,-4], k = 2输出：13解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示： 1 &lt;= nums.length &lt;= 104 -100 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 104 12345678910111213141516171819202122import java.util.Arrays;import java.util.stream.IntStream;class Solution { public int largestSumAfterKNegations(int[] nums, int k) { nums = IntStream.of(nums) .boxed() .sorted((a,b)-&gt; Math.abs(b)-Math.abs(a)) .mapToInt(Integer::intValue) .toArray(); for (int i = 0 ; i &lt; nums.length &amp;&amp; k &gt; 0; i++) { if (nums[i] &lt; 0 ) { nums[i] = -1 * nums[i]; k--; } } if (k % 2 == 1) { nums[nums.length-1] = -1 * nums[nums.length-1]; } return Arrays.stream(nums).sum(); }} 9、加油站在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 123456789输入: gas = [2,3,4], cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 提示: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 1234567891011121314151617181920class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int curcost = 0; int totalcost = 0; int result = 0; for (int i = 0; i &lt; gas.length; i++) { curcost += gas[i] - cost[i]; totalcost += gas[i] - cost[i]; if (curcost &lt; 0) { result = i+1; curcost = 0; } } if (totalcost &gt;= 0) { return result; }else { return -1; } }} 10、分发糖果n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 123输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2： 1234输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示： n == ratings.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= ratings[i] &lt;= 2 * 104 1234567891011121314151617181920212223242526class Solution { public int candy(int[] ratings) { int len = ratings.length; int [] candys = new int [len]; int result = 0; // 先从左往右 比较右孩子和左孩子的关系 candys[0] = 1; for(int i = 1; i &lt; len; i++) { if (ratings[i] &gt; ratings[i-1]) { candys[i] = candys[i-1]+1; }else { candys[i] = 1; } } // 再从右往左，比较左孩子和右孩子的关系，取上下两次遍历的最大值 for(int i = len - 2; i &gt;= 0; i--) { if (ratings[i] &gt; ratings[i+1]) { candys[i] = Math.max(candys[i],candys[i+1]+1); } } for (int i : candys) { result += i; } return result; }} 11、柠檬水找零在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1： 1234567输入：bills = [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 1234567输入：bills = [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 1 &lt;= bills.length &lt;= 105 bills[i] 不是 5 就是 10 或是 20 12345678910111213141516171819202122232425class Solution { public boolean lemonadeChange(int[] bills) { int five = 0; int ten = 0; for (int i = 0; i &lt; bills.length; i++) { if (bills[i] == 5) { five ++; }else if (bills[i] == 10) { five --; ten ++; }else if (bills[i] == 20) { if (ten &gt; 0) { ten--; five--; }else { five -=3; } } if (ten &lt; 0 ||five &lt; 0) { return false; } } return true; }} 12、根据身高建队列假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 12345678910输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 12输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= hi &lt;= 106 0 &lt;= ki &lt; people.length 题目数据确保队列可以被重建 123456789101112131415161718192021import java.util.Arrays;import java.util.LinkedList;class Solution { public int[][] reconstructQueue(int[][] people) { // 第一个元素是身高，第二个元素是允许多少个人在他前面，身高相同时，第二个元素升序排列 Arrays.sort(people,(a,b)-&gt;{ if(a[0] == b[0]){ return a[1]-b[1]; } return b[0] - a[0]; }); LinkedList &lt;int[]&gt; que = new LinkedList&lt;&gt;(); for (int[] i : people) { que.add(i[1], i); } return que.toArray(new int [people.length][]); }} 13、用最少数量的箭引爆气球有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 示例 1： 12345输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用2支箭来爆破:-在x = 6处射出箭，击破气球[2,8]和[1,6]。-在x = 11处发射箭，击破气球[10,16]和[7,12]。 示例 2： 123输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4解释：每个气球需要射出一支箭，总共需要4支箭。 示例 3： 12345输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2解释：气球可以用2支箭来爆破:- 在x = 2处发射箭，击破气球[1,2]和[2,3]。- 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示: 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 1234567891011121314class Solution { public int findMinArrowShots(int[][] points) { int result = 1; Arrays.sort(points,(a,b)-&gt;Integer.compare(a[0],b[0])); for (int i = 1; i &lt; points.length; i++) { if (points[i][0] &gt; points[i-1][1]) { result ++; } else { points[i][1] = Math.min(points[i][1],points[i-1][1]); } } return result; }} 14、无重叠区域给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。 示例 1: 123输入: intervals = [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 123输入: intervals = [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 123输入: intervals = [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示: 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 12345678910111213class Solution { public int eraseOverlapIntervals(int[][] intervals) { int result = 0; Arrays.sort(intervals,(a,b) -&gt; Integer.compare(a[0],b[0])); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i][0] &lt; intervals[i-1][1]) { result ++; intervals[i][1] = Math.min(intervals[i-1][1],intervals[i][1]); } } return result; }} 15、划分字母区间给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 示例 1： 123456输入：s = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 示例 2： 12输入：s = &quot;eccbbbbdec&quot;输出：[10] 提示： 1 &lt;= s.length &lt;= 500 s 仅由小写英文字母组成 1234567891011121314151617181920class Solution { public List&lt;Integer&gt; partitionLabels(String s) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); int[] edge = new int[26]; char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { edge[chars[i]-'a'] = i; } int end = 0; int start = -1; for (int i = 0; i &lt; chars.length; i++) { end = Math.max(edge[chars[i]-'a'],end); if (end == i) { result.add(end-start); start = end; } } return result; }} 16、合并区间以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 123输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 123输入：intervals = [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 12345678910111213141516171819class Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; result = new LinkedList&lt;&gt;(); Arrays.sort(intervals, (a,b)-&gt;Integer.compare(a[0],b[0])); int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i][0] &lt;= end) { end = Math.max(intervals[i][1],end); } else { result.add(new int[] {start,end}); start = intervals[i][0]; end = intervals[i][1]; } } result.add(new int[] {start,end}); return result.toArray(new int[result.size()][]); }} 17、单调递增的数字当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。 示例 1: 12输入: n = 10输出: 9 示例 2: 12输入: n = 1234输出: 1234 示例 3: 12输入: n = 332输出: 299 提示: 0 &lt;= n &lt;= 109 1234567891011121314151617class Solution { public int monotoneIncreasingDigits(int n) { String s = String.valueOf(n); char[] chars = s.toCharArray(); int label = chars.length; for (int i = chars.length-2; i &gt;= 0; i--) { if (chars[i] &gt; chars[i+1]) { chars[i]--; label = i + 1; } } for (int i = label; i &lt; chars.length; i++) { chars[i] = '9'; } return Integer.parseInt(String.valueOf(chars)); }} 18、监控二叉树https://leetcode.cn/problems/binary-tree-cameras/description/ 给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 示例 1： 123输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。 示例 2： 123输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int res = 0; public int minCameraCover(TreeNode root) { // 0表示无覆盖，1表示有摄像头，2表示有覆盖 // 当根节点无覆盖时需要++ if (minCam(root) == 0) { res++; } return res; } public int minCam(TreeNode root) { // 遍历到空节点时返回2 表示有覆盖，这样叶子节点才会被赋值0 无覆盖，叶子节点的父节点会被赋值1 装摄像头 if (root == null) { return 2; } int left = minCam(root.left); int right = minCam(root.right); // 左右叶子节点都是有覆盖，父节点要被赋值0 无覆盖 if (left==2 &amp;&amp; right==2) { return 0; } // 左右节点有一个没有被覆盖就要装摄像头 else if (left==0 || right ==0) { res++; return 1; } // 左右节点有一个有摄像头，父节点就是被 else { return 2; } }}","link":"/2024/11/09/leetcode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"title":"回溯算法","text":"回溯算法 1、组合力扣题目链接 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例 1： 12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 示例 2： 12输入：n = 1, k = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= n 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;&gt;(); backtrace(1,n,k,current,result); return result; } public void backtrace (int start, int n, int k, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt;result) { if(current.size() == k) { result.add(new ArrayList&lt;&gt;(current)); return; } for (int i = start; i &lt;= n; i++) { current.add(i); backtrace(i + 1, n, k, current, result); current.remove(current.size()-1); } }} 2、组合优化12345678910111213141516171819class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;Integer&gt; trace = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { track(n,1,k); return result; } public void track (int n, int start, int k) { if (trace.size() == k) { result.add(new LinkedList(trace)); return; } for (int i = start ; i &lt;= n-(k-trace.size())+1; i++) { trace.add(i); track(n,i+1,k); trace.removeLast(); } }} 3. 组合总和IIIhttps://leetcode.cn/problems/combination-sum-iii/description/ 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例 1: 12345输入: k = 3, n = 7输出: [[1,2,4]]解释:1 + 2 + 4 = 7没有其他符合的组合了。 示例 2: 1234567输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。 示例 3: 1234输入: k = 4, n = 1输出: []解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。 提示: 2 &lt;= k &lt;= 9 1 &lt;= n &lt;= 60 1234567891011121314151617181920212223242526class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;Integer&gt; trace = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { backtrack(k,n,1,0); return result; } public void backtrack (int k, int n, int start, int sum) { if (trace.size()==k) { if (sum == n) { result.add(new LinkedList(trace)); } return; } if (sum &gt; n) { return; } for (int i = start; i &lt;= 9-(k-trace.size())+1; i++) { sum += i; trace.add(i); backtrack(k,n,i+1,sum); sum -= i; trace.removeLast(); } }} 4. 电话号码的字母组合https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/ 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 12输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] 示例 2： 12输入：digits = &quot;&quot;输出：[] 示例 3： 12输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 12345678910111213141516171819202122232425class Solution { List&lt;String&gt; result = new LinkedList&lt;&gt;(); String[] numString = {&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;}; StringBuilder sb = new StringBuilder(); public List&lt;String&gt; letterCombinations(String digits) { if (digits == null || digits.length()==0) { return result; } backTracking (digits,0); return result; } void backTracking(String digits, int index) { if (index == digits.length()) { result.add(sb.toString()); return; } int digit = digits.charAt(index) - '0'; String str = numString[digit]; for (int i = 0; i &lt; str.length(); i++) { sb.append(str.charAt(i)); backTracking(digits,index+1); sb.deleteCharAt(sb.length()-1); } }} 5.组合总和https://leetcode.cn/problems/combination-sum/description/ 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 示例 2： 12输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 12输入: candidates = [2], target = 1输出: [] 提示： 1 &lt;= candidates.length &lt;= 30 2 &lt;= candidates[i] &lt;= 40 candidates 的所有元素 互不相同 1 &lt;= target &lt;= 40 123456789101112131415161718192021222324class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;Integer&gt; trace = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { backTracing(candidates,target,0,0); return result; } void backTracing (int [] candidates, int target, int sum, int startIndex) { if (sum == target) { result.add(new LinkedList(trace)); return; } if (sum &gt; target) { return; } for (int i = startIndex; i &lt; candidates.length; i++) { sum += candidates[i]; trace.add(candidates[i]); backTracing(candidates,target,sum,i); sum -= trace.get(trace.size()-1); trace.removeLast(); } }} 6.组合总和II给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]] 提示: 1 &lt;= candidates.length &lt;= 100 1 &lt;= candidates[i] &lt;= 50 1 &lt;= target &lt;= 30 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; trace = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backTracing(candidates, target, 0, 0); return result; } void backTracing (int[] candidates, int target, int sum, int startIndex) { if (sum == target) { result.add(new LinkedList(trace)); return; } if (sum &gt; target) { return; } for (int i = startIndex; i &lt; candidates.length; i++) { if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]) { continue; } trace.add(candidates[i]); sum += candidates[i]; backTracing(candidates, target, sum, i+1); sum -= trace.get(trace.size()-1); trace.removeLast(); } } } 6. 分割回文串https://leetcode.cn/problems/palindrome-partitioning/ 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 示例 1： 12输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] 示例 2： 12输入：s = &quot;a&quot;输出：[[&quot;a&quot;]] 提示： 1 &lt;= s.length &lt;= 16 s 仅由小写英文字母组成 123456789101112131415161718192021222324252627282930class Solution { List&lt;List&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;String&gt; trace = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) { backTracking(s,0); return result; } void backTracking(String s, int startIndex) { if (startIndex == s.length()) { result.add(new LinkedList(trace)); return; } for (int i = startIndex; i &lt; s.length(); i++) { String sb = s.substring(startIndex,i+1); if(isPalindrome(sb)) { trace.add(sb); backTracking(s,i+1); trace.removeLast(); } } } boolean isPalindrome (String s) { for (int i = 0, j = s.length()-1; i &lt; j; i++, j--) { if (s.charAt(i) != s.charAt(j)) { return false; } } return true; }} 7.复原IP地址https://leetcode.cn/problems/restore-ip-addresses/description/ 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例 1： 12输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;] 示例 2： 12输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;] 示例 3： 12输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;] 提示： 1 &lt;= s.length &lt;= 20 s 仅由数字组成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) { backTracking(s,0,0); return result; } void backTracking(String s, int startIndex, int pointSum) { if (pointSum == 3) { if (isVaild(s,startIndex,s.length()-1)) { result.add(s); return; } } for (int i = startIndex ; i &lt; s.length(); i++) { if (isVaild(s,startIndex,i)){ s = s.substring(0,i+1) + '.' + s.substring(i+1); pointSum++; backTracking(s,i+2,pointSum); pointSum--; s = s.substring(0,i+1) + s.substring(i+2); } } } boolean isVaild (String s, int start, int end) { // 1. 每个整数都在0-255之间 // 2. 不还有特殊字符 // 3. 首位不为0 if (start &gt; end) { return false; } if ((end-start) &gt;= 1 &amp;&amp; s.charAt(start) == '0') { return false; } int num = 0; for (int i = start; i &lt;= end; i++) { int temp = s.charAt(i) - '0'; if ( temp &gt; 9 || temp &lt; 0 ) { return false; } num = 10*num + temp; } if ( num &gt; 255 || num &lt; 0 ) { return false; } return true; }} 8.子集问题https://leetcode.cn/problems/subsets/ 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 1234567891011121314151617class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; trace = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { backTracking(nums,0); return result; } void backTracking (int[] nums, int startIndex) { if (startIndex &gt; nums.length) return; result.add(new ArrayList(trace)); for (int i = startIndex; i &lt; nums.length; i++) { trace.add(nums[i]); backTracking(nums,i+1); trace.removeLast(); } }} 9.子集IIhttps://leetcode.cn/problems/subsets-ii/description/ 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例 1： 12输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 1234567891011121314151617181920212223import java.util.List;import java.util.ArrayList;import java.util.Arrays;class Solution { public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); Arrays.sort(nums); dfs(nums, 0, path, result); return result; } void dfs(int[] nums, int start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result) { result.add(new ArrayList&lt;&gt;(path)); for (int i = start; i &lt; nums.length; i++) { if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) { continue; } path.add(nums[i]); dfs(nums, i+1, path, result); path.remove(path.size()-1); } }} 12345678910111213141516171819202122232425262728import java.util.List;import java.util.ArrayList;import java.util.Arrays;class Solution { private List&lt;List&lt;Integer&gt;&gt; result; private List&lt;Integer&gt; path; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { result = new ArrayList&lt;&gt;(); path = new ArrayList&lt;&gt;(); Arrays.sort(nums); backTracking(nums, 0); return result; } private void backTracking(int[] nums, int start) { result.add(new ArrayList&lt;&gt;(path)); for (int i = start; i &lt; nums.length; i++) { if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) { continue; } path.add(nums[i]); backTracking(nums, i + 1); path.remove(path.size() - 1); } }} 10、递增子序列https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 示例 1： 12输入：nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例 2： 12输入：nums = [4,4,3,2,1]输出：[[4,4]] 提示： 1 &lt;= nums.length &lt;= 15 -100 &lt;= nums[i] &lt;= 100 1234567891011121314151617181920212223242526272829class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; trace = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) { backTracking(nums, 0); return result; } void backTracking(int[] nums, int stratIndex) { if(stratIndex &gt; nums.length) { return; } if (trace.size()&gt;=2) { result.add(new ArrayList(trace)); } Set&lt;Integer&gt; used = new HashSet&lt;&gt;(); for (int i = stratIndex; i &lt; nums.length; i++) { if (!trace.isEmpty() &amp;&amp; nums[i] &lt; trace.get(trace.size()-1)) { continue; } if (used.contains(nums[i])) { continue; } trace.add(nums[i]); used.add(nums[i]); backTracking(nums,i+1); trace.remove(trace.size()-1); } } } 11、全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例 3： 12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 12345678910111213141516171819202122232425class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; trace = new ArrayList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { used = new boolean [nums.length]; backTracking(nums); return result; } void backTracking(int[] nums) { if (trace.size() == nums.length) { result.add(new ArrayList(trace)); } for (int i = 0; i &lt; nums.length; i++) { if (used[i]) { continue; } trace.add(nums[i]); used[i] = true; backTracking(nums); used[i] = false; trace.remove(trace.size()-1); } }} 12、全排列II给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 12345输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]] 示例 2： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示： 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; trace = new ArrayList&lt;&gt;(); boolean [] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { used = new boolean [nums.length]; backTracking(nums); return result; } void backTracking (int[] nums) { if(trace.size() == nums.length){ result.add(new ArrayList(trace)); return; } Set&lt;Integer&gt; appear = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { if(used[i] || appear.contains(nums[i])) { continue; } appear.add(nums[i]); used[i] = true; trace.add(nums[i]); backTracking(nums); used[i] = false; trace.remove(trace.size()-1); } }} 13、重新安排行程给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 示例 1： 12输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;] 示例 2： 123输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。 提示： 1 &lt;= tickets.length &lt;= 300 tickets[i].length == 2 fromi.length == 3 toi.length == 3 fromi 和 toi 由大写英文字母组成 fromi != toi 1234567891011121314151617181920class Solution { public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) { Map&lt;String, PriorityQueue&lt;String&gt;&gt; graph = new HashMap(); for (List&lt;String&gt; ticket : tickets) { graph.putIfAbsent(ticket.get(0),new PriorityQueue&lt;String&gt;()); graph.get(ticket.get(0)).offer(ticket.get(1)); } List&lt;String&gt; result = new LinkedList&lt;&gt;(); dfs (&quot;JFK&quot;,graph,result); return result; } void dfs (String head, Map&lt;String, PriorityQueue&lt;String&gt;&gt; graph, List&lt;String&gt; result) { while (graph.containsKey(head) &amp;&amp; !graph.get(head).isEmpty()){ String next = graph.get(head).poll(); dfs(next,graph,result); } result.addFirst(head); }} PriorityQueue 是一种特殊的队列，它按照优先级来处理队列中的元素，而不是按照元素被插入队列的顺序。在 PriorityQueue 中，元素的优先级决定了它们的出队顺序。通常，优先级高的元素会先被处理。它在许多算法和数据结构中都有应用，尤其是在需要按优先级进行调度、排序、合并等操作的场景中。 Java 中的 PriorityQueue在 Java 中，PriorityQueue 是一个实现了 Queue 接口的类，它提供了一个基于堆（通常是最小堆）实现的队列。它会按照元素的自然顺序或通过传递的 Comparator 来决定优先级。 主要特点： 最小堆（Min-Heap）： 默认情况下，PriorityQueue 使用自然顺序（元素的比较方法，如数字的大小或字符串的字典顺序），这意味着队列中最小的元素会先被移除。 可以通过传入 Comparator 来改变优先级的顺序，使用最大堆（Max-Heap）或自定义顺序。 无界队列： PriorityQueue 默认没有容量限制，元素数量只受可用内存的限制。 线程不安全： PriorityQueue 不是线程安全的，如果多个线程并发操作同一个队列，需要使用外部同步机制，或者使用 PriorityBlockingQueue 来替代。 基本操作： add(E e) / offer(E e)：向队列添加元素。 remove() / poll()：移除并返回队列中优先级最高的元素（对于最小堆，就是最小的元素）。 peek()：返回队列中优先级最高的元素，但不移除它。 size()：返回队列中元素的数量。 clear()：清空队列中的所有元素。 1234567891011121314151617181920```#### 14、N皇后按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。 **示例 1：**![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg) 输入：n = 4输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]解释：如上图所示，4 皇后问题存在两个不同的解法。 123**示例 2：** 输入：n = 1输出：[[“Q”]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758**提示：**- `1 &lt;= n &lt;= 9````javaclass Solution { List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { char[][] chessboard = new char[n][n]; for (char[]c : chessboard) { Arrays.fill(c,'.'); } backTracking(chessboard,n,0); return result; } void backTracking(char[][] chessboard,int n, int row){ if (row == n) { result.add(ArrayToList(chessboard)); return; } for (int i = 0; i &lt; n; i++) { if (isVaild(chessboard,n,row,i)){ chessboard[row][i] = 'Q'; backTracking(chessboard,n,row+1); chessboard[row][i] = '.'; } } } List&lt;String&gt; ArrayToList(char[][]chessboard) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[]c : chessboard) { list.add(String.copyValueOf(c)); } return list; } boolean isVaild (char[][] chessboard, int n, int row, int column) { // 检查同一列列是否有Q for(int i = 0; i &lt;= row; i++) { if(chessboard[i][column] == 'Q') { return false; } } // 检查45度斜线 for (int i = row -1, j = column - 1; i&gt;=0&amp;&amp;j&gt;=0; i--,j--) { if(chessboard[i][j] == 'Q') { return false; } } // 检查135度 for (int i = row -1, j = column + 1; i&gt;=0&amp;&amp;j&lt;n; i--,j++) { if(chessboard[i][j] == 'Q') { return false; } } return true; }} 15、解数独编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1： 123输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.' 题目数据 保证 输入数独仅有一个解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public void solveSudoku(char[][] board) { backTracking (board); } boolean backTracking(char[][] board) { for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { continue; } for (char k = '1'; k &lt;= '9'; k++) { if (isVaild(board,i,j,k)){ board[i][j] = k; if (backTracking(board)){ return true; } board[i][j] = '.'; } } return false; } } return true; } boolean isVaild(char[][]board, int row, int column, char k){ for (int i = 0; i &lt; 9; i++) { if (board[row][i] == k) { return false; } } for (int i = 0; i &lt; 9; i++) { if(board[i][column] == k) { return false; } } for (int i = (row/3)*3; i &lt; (row/3)*3+3; i++) { for (int j = (column/3)*3; j&lt;(column/3)*3+3;j++) { if(board[i][j]==k) { return false; } } } return true; } }","link":"/2024/09/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"碎语","slug":"碎语","link":"/tags/%E7%A2%8E%E8%AF%AD/"},{"name":"实验室区块链","slug":"实验室区块链","link":"/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"碎语","slug":"碎语","link":"/categories/%E7%A2%8E%E8%AF%AD/"},{"name":"区块链","slug":"区块链","link":"/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}],"pages":[]}